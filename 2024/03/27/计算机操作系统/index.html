
<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8" />
    <title>计算机操作系统 | 雲流のLowest World</title>
    <meta name="author" content="C1oudfL0w0" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
    <link rel="icon" href="/blog/images/croppedImage_cropped.jpg" />
    <!-- cdn挂掉的时候要可以引用本地 -->
<!-- <script src="https://cdn.staticfile.org/vue/3.2.45/vue.global.prod.min.js"></script> -->
<script src="/blog/js/vue.global.prod.min.js"></script>


<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.2.1/css/all.min.css" />


<link rel="stylesheet" href="/blog/css/all.min.css" />
<link rel="stylesheet" href="/blog/css/fonts.min.css" />
<link rel="stylesheet" href="/blog/css/search.css" />
<script> const mixins = {}; </script>

<!-- 引入jQuery-->
<!-- <script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script> -->
<script src="/blog/js/jquery.min.js"></script>

<!--改成了prismjs高亮-->

<script src="/blog/js/lib/prism.js"></script>
<link rel="stylesheet" href="/blog/css/prism.css" rel="stylesheet" />



<script src="/blog/js/lib/preview.js"></script>










<script src="/blog/js/lib/home.js"></script>

<link rel="stylesheet" href="/blog/css/main.css" />
<!-- 引入不蒜子-->

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script type="text/javascript" src="/blog/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/blog/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<!-- 引入clipboard -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.8/clipboard.min.js"></script>

<script type="text/javascript" src="/blog/libs/codeBlock/codeCopy.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/blog/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/blog/atom.xml" title="雲流のLowest World" type="application/atom+xml">
</head>

<body>
    <!--flag{never_g0nna g1ve_you up}-->

    <!-- 页面点击特效 -->
    <script type="text/javascript" src="/blog/js/love-click.js"></script>

    <!-- 浏览器标题 -->
    <script async type="text/javascript" src="/blog/js/FunnyTitle.js"></script>

    <!-- 动态背景 -->
    

    <!--文章目录-->
    
    <div id="toc" class="toc-article">
    <h3><i class="fas fa-stream"></i>  目录</h3>
      <div class="toc-title"></div>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%AE%BA"><span class="toc-number">2.</span> <span class="toc-text">引论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">操作系统定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.</span> <span class="toc-text">主要功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.1.</span> <span class="toc-text">提供接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.2.</span> <span class="toc-text">资源管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E6%8A%BD%E8%B1%A1"><span class="toc-number">2.2.3.</span> <span class="toc-text">资源抽象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">操作系统的发展过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%92%8C%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">集成电路和多道批处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">CPU利用率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">分时系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">2.4.</span> <span class="toc-text">基本特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">2.4.1.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB"><span class="toc-number">2.4.2.</span> <span class="toc-text">共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F"><span class="toc-number">2.4.3.</span> <span class="toc-text">虚拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">2.4.4.</span> <span class="toc-text">异步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.</span> <span class="toc-text">运行机制与体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.5.1.</span> <span class="toc-text">状态转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">2.6.</span> <span class="toc-text">中断和异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.7.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">2.8.</span> <span class="toc-text">操作系统结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-amp-%E7%89%B9%E5%BE%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">定义&amp;特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.2.</span> <span class="toc-text">进程与程序的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">3.1.3.</span> <span class="toc-text">进程的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PCB"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">PCB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%AE%B5"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">程序段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">数据段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.3.4.</span> <span class="toc-text">层次结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">3.1.4.</span> <span class="toc-text">进程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">基本状态与转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">3.2.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C"><span class="toc-number">3.2.2.</span> <span class="toc-text">执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2"><span class="toc-number">3.2.3.</span> <span class="toc-text">切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2"><span class="toc-number">3.2.4.</span> <span class="toc-text">终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92"><span class="toc-number">3.2.5.</span> <span class="toc-text">阻塞与唤醒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88IPC%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">进程通信（IPC）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.1.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB%E2%80%94%E2%80%94%E7%9B%B8%E4%BA%92%E5%90%88%E4%BD%9C"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">直接制约关系——相互合作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">间接制约关系——共享资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">临界资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">3.3.1.5.</span> <span class="toc-text">进程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">3.3.1.6.</span> <span class="toc-text">进程互斥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">进程通信方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">共享存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">管道通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">消息传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E6%9C%BA%EF%BC%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">客户机－服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.3.</span> <span class="toc-text">进程间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">3.4.</span> <span class="toc-text">术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.1.</span> <span class="toc-text">原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">3.4.2.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF"><span class="toc-number">3.4.3.</span> <span class="toc-text">饥饿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">互斥访问的实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%A7%A3%E6%B3%95"><span class="toc-number">3.5.1.</span> <span class="toc-text">软件解法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dekker%E8%A7%A3%E6%B3%95%E2%80%94%E2%80%94%E4%B8%89%E6%A0%87%E5%BF%97%E6%B3%95"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">Dekker解法——三标志法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Peterson%E8%A7%A3%E6%B3%95"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">Peterson解法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%A7%A3%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">硬件解法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-1"><span class="toc-number">3.6.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">3.6.1.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">3.6.2.</span> <span class="toc-text">管程机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8IPC%E9%97%AE%E9%A2%98"><span class="toc-number">3.6.3.</span> <span class="toc-text">经典IPC问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8D%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">生产者－消费者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%8D%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.6.3.2.</span> <span class="toc-text">多生产者－多消费者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%EF%BC%8D%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.6.3.3.</span> <span class="toc-text">读者－写者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%EF%BC%9A%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-number">3.6.3.3.1.</span> <span class="toc-text">解法一：读者优先</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%86%99%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-number">3.6.3.3.2.</span> <span class="toc-text">解法二：写者优先</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">3.6.3.4.</span> <span class="toc-text">哲学家进餐问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.7.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.1.</span> <span class="toc-text">与进程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD-1"><span class="toc-number">3.7.2.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">3.7.3.</span> <span class="toc-text">分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">三个问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.</span> <span class="toc-text">调度概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA"><span class="toc-number">4.2.1.</span> <span class="toc-text">调度时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E8%BF%87%E7%A8%8B%EF%BC%88%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%EF%BC%89"><span class="toc-number">4.2.2.</span> <span class="toc-text">调度过程（进程切换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%B1%82%E6%AC%A1"><span class="toc-number">4.2.3.</span> <span class="toc-text">调度层次</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">4.3.1.</span> <span class="toc-text">性能指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">多道批处理系统的调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.3.</span> <span class="toc-text">交互式系统的调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.4.</span> <span class="toc-text">实时系统调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">死锁处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A6%82%E8%BF%B0"><span class="toc-number">4.4.1.</span> <span class="toc-text">死锁概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%BB%BA%E6%A8%A1"><span class="toc-number">4.4.2.</span> <span class="toc-text">死锁建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">4.4.3.</span> <span class="toc-text">处理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%B8%B5%E9%B8%9F%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">鸵鸟算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">死锁避免</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.3.2.1.</span> <span class="toc-text">银行家算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">4.4.3.3.</span> <span class="toc-text">预防死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%92%8C%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-number">4.4.3.4.</span> <span class="toc-text">死锁检测和死锁恢复</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">存储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.1.</span> <span class="toc-text">分层存储器系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9F%BA%E7%A1%80"><span class="toc-number">5.1.1.</span> <span class="toc-text">内存基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">5.1.2.</span> <span class="toc-text">内存保护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.</span> <span class="toc-text">程序的装入和链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E5%85%A5"><span class="toc-number">5.2.1.</span> <span class="toc-text">装入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">静态重定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">动态重定位</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.2.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">静态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E5%85%A5%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">装入时动态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">运行时动态链接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">连续分配存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.1.</span> <span class="toc-text">碎片问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">5.3.2.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">5.3.3.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">5.3.4.</span> <span class="toc-text">动态分区分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.4.1.</span> <span class="toc-text">分配算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%9B%9E%E6%94%B6"><span class="toc-number">5.3.4.2.</span> <span class="toc-text">分配回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">非连续分配方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-number">5.4.1.</span> <span class="toc-text">交换技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">覆盖技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF-1"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">交换技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.2.</span> <span class="toc-text">地址空间结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">5.4.3.</span> <span class="toc-text">分页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">地址转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8"><span class="toc-number">5.4.3.4.</span> <span class="toc-text">快表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">5.4.3.5.</span> <span class="toc-text">多级页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">5.4.3.6.</span> <span class="toc-text">基址变换机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">5.4.3.7.</span> <span class="toc-text">地址转换的计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">5.4.4.</span> <span class="toc-text">分段存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-number">5.4.4.1.</span> <span class="toc-text">段表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">请求分页存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.1.</span> <span class="toc-text">页表机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="toc-number">6.2.2.</span> <span class="toc-text">缺页中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">6.2.3.</span> <span class="toc-text">地址变换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">6.3.</span> <span class="toc-text">虚拟内存管理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E7%AD%96%E7%95%A5"><span class="toc-number">6.3.1.</span> <span class="toc-text">读取策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5"><span class="toc-number">6.3.2.</span> <span class="toc-text">放置策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">6.3.3.</span> <span class="toc-text">置换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FIFO"><span class="toc-number">6.3.3.1.1.</span> <span class="toc-text">FIFO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OPT"><span class="toc-number">6.3.3.1.2.</span> <span class="toc-text">OPT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LRU"><span class="toc-number">6.3.3.1.3.</span> <span class="toc-text">LRU</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Clock"><span class="toc-number">6.3.3.1.4.</span> <span class="toc-text">Clock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%BC%93%E5%86%B2"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">页缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">工作集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%BB%E7%95%99%E9%9B%86%E7%AE%A1%E7%90%86"><span class="toc-number">6.3.4.</span> <span class="toc-text">驻留集管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">6.3.4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">6.3.4.2.</span> <span class="toc-text">分配策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E8%8C%83%E5%9B%B4"><span class="toc-number">6.3.4.3.</span> <span class="toc-text">置换范围</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">6.3.5.</span> <span class="toc-text">清除策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">请求分段存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="toc-number">6.4.1.</span> <span class="toc-text">硬件支持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%AE%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">请求段表机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E6%AE%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">缺段中断机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">地址变换机构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="toc-number">6.4.2.</span> <span class="toc-text">共享与保护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">输入输出系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">7.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%97%A0%E5%85%B3%E6%80%A7"><span class="toc-number">7.1.1.</span> <span class="toc-text">设备无关性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-1"><span class="toc-number">7.1.2.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%BC%A0%E8%BE%93%E9%80%9F%E7%8E%87%E7%9C%8B"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">从传输速率看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E4%BF%A1%E6%81%AF%E5%8D%95%E4%BD%8D%E7%9C%8B"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">从信息单位看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%9C%8B"><span class="toc-number">7.1.2.3.</span> <span class="toc-text">从资源分配看</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.</span> <span class="toc-text">硬件原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">7.2.1.</span> <span class="toc-text">IO控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">主要任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">组成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.2.</span> <span class="toc-text">IO控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">中断驱动方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">DMA方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.2.3.</span> <span class="toc-text">IO通道控制方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">软件原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%88%92%E5%88%86"><span class="toc-number">7.3.1.</span> <span class="toc-text">层次划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%85%B3%E9%94%AE"><span class="toc-number">7.3.2.</span> <span class="toc-text">设计关键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.3.3.</span> <span class="toc-text">核心子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF%EF%BC%88SPOOLing%EF%BC%89"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">假脱机技术（SPOOLing）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">7.3.3.2.</span> <span class="toc-text">缓冲区管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">7.3.3.2.1.</span> <span class="toc-text">双缓冲</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%EF%BC%88%E7%A3%81%E7%9B%98%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">输入输出设备（磁盘）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="toc-number">7.4.1.</span> <span class="toc-text">性能参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95-1"><span class="toc-number">7.4.2.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1FCFS"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">先来先服务FCFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E4%BC%98%E5%85%88SSF"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">最短寻道优先SSF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E6%A2%AF%E7%AE%97%E6%B3%95SCAN"><span class="toc-number">7.4.2.3.</span> <span class="toc-text">电梯算法SCAN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95CSCAN"><span class="toc-number">7.4.2.4.</span> <span class="toc-text">循环扫描算法CSCAN</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">8.1.</span> <span class="toc-text">文件和文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">8.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.2.</span> <span class="toc-text">文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">逻辑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">物理结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.1.3.</span> <span class="toc-text">文件类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">8.1.4.</span> <span class="toc-text">文件访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%B3%BB%E7%BB%9F"><span class="toc-number">8.2.</span> <span class="toc-text">目录系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">8.2.1.</span> <span class="toc-text">文件控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.2.</span> <span class="toc-text">目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%A7%E7%9B%AE%E5%BD%95"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">单级目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95"><span class="toc-number">8.2.2.2.</span> <span class="toc-text">两级目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%EF%BC%88%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%EF%BC%89"><span class="toc-number">8.2.2.3.</span> <span class="toc-text">多级目录（树形目录）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9B%AE%E5%BD%95"><span class="toc-number">8.2.2.4.</span> <span class="toc-text">有向无环图目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84"><span class="toc-number">8.2.3.</span> <span class="toc-text">路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5-1"><span class="toc-number">8.2.4.</span> <span class="toc-text">链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-number">8.2.5.</span> <span class="toc-text">目录操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.3.</span> <span class="toc-text">文件系统的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-number">8.3.1.</span> <span class="toc-text">文件系统的布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.3.2.</span> <span class="toc-text">文件的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">连续空间存放方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">非连续空间存放方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">8.3.2.2.1.</span> <span class="toc-text">链表方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="toc-number">8.3.2.2.2.</span> <span class="toc-text">索引方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6"><span class="toc-number">8.3.3.</span> <span class="toc-text">共享文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">硬链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%EF%BC%88%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="toc-number">8.3.3.2.</span> <span class="toc-text">软链接（符号链接）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD"><span class="toc-number">8.3.3.3.</span> <span class="toc-text">文件挂载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">8.3.4.</span> <span class="toc-text">文件存储空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%B3%95"><span class="toc-number">8.3.4.1.</span> <span class="toc-text">位示图法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">磁盘存储器管理</span></a></li></ol>
    </div>
  

    <!--返回顶部-->
    <div id="totop" style="position:fixed;bottom:50px;right:60px;font-size: 48px;cursor: pointer;z-index: 10;">
        <a title="返回顶部">↑</a>
    </div>
    <script src="/blog/js/totop.js"></script>

    <div id="layout">
        
            <div id="content-background" ref="contentBackground" data-images="https://pic.imgdb.cn/item/65d61d809f345e8d03b8bc7a.png"></div>
            
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>第一次加载文章图片可能会花费较长时间</p>
                    <p>要不挂个梯子试试？（x</p>
                    <p>加载过慢请开启缓存&ensp;浏览器默认开启</p>
                    <img src="/blog/images/loading.gif" />
                </div>
            </div>
        </transition>
        <transition name="into">
            <div id="main" v-show="!loading">
                <nav id="menu" ref="menu">
    <div class="desktop-menu">
        <a class="title" href="/blog/">
            <span>雲流のLOWEST WORLD</span>
        </a>
        
        <a href="/blog/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/blog/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/blog/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/blog/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/blog/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
        <a href="/blog/links">
            <i class="fa-solid fa-link fa-fw"></i>
            <span>&ensp;Links</span>
        </a>
        
        <a href="/blog/search">
            <i class="fa-solid fa-search fa-fw"></i>
            <span>&ensp;Search</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" v-show="showMenu" @click="showMenu = !showMenu"></div>
        <div class="title" @click="showMenu = !showMenu">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;雲流のLOWEST WORLD</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="showMenu">
            
            <a href="/blog/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/blog/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/blog/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/blog/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/blog/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
            <a href="/blog/links">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-link fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Links</div>
                </div>
            </a>
            
            <a href="/blog/search">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-search fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Search</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

                <div class="article">
    <div>
        <h1>计算机操作系统</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/3/27
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/blog/tags/408/" style="color: #ff7d73">408</a>
            </span>
            
        </span>
        
        <!--文章字数统计-->
        
            
<div style="margin-top:10px;">
    <span class="post-time">
      <span class="post-meta-item-icon">
        <i class="fa fa-keyboard-o"></i>
        <span class="post-meta-item-text">  字数统计: </span>
        <!-- 安装插件npm install hexo-wordcount --save -->
        <span class="post-count">24.9k字</span>
      </span>
    </span>

    <span class="post-time">
      &nbsp; | &nbsp;
      <span class="post-meta-item-icon">
        <i class="fa fa-hourglass-half"></i>
        <span class="post-meta-item-text">  阅读时长: </span>
        <span class="post-count">86分</span>
      </span>
    </span>
    
    <!--不蒜子统计访问数-->
    <span id="busuanzi_container_page_pv">
    &nbsp; | &nbsp;
    总文章阅读量：<span id="busuanzi_value_page_pv"></span>次
    </span>
</div>

          
    </div>
    
    <div class="content" v-pre>
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机408之操作系统</p>
<p>参考：上课的课件和《计算机操作系统（慕课版）》，以及b站大学，各路博客</p>
<span id="more"></span>

<hr>
<h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514222255415.png" alt="image-20240514222255415"></p>
<h2 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h2><p>是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境</p>
<p>是一种（系统）软件，是安装在计算机硬件上的第一层软件</p>
<p>shell：用户交互程序</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514222426446.png" alt="image-20240514222426446"></p>
<hr>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><p>从人机交互、资源管理及资源抽象等不同方面来分析：</p>
<ul>
<li><p>OS作为<strong>用户与计算机硬件系统之间的接口</strong></p>
</li>
<li><p>OS作为<strong>计算机系统资源的管理者</strong></p>
</li>
<li><p>OS实现了<strong>对计算机资源的抽象</strong>。</p>
</li>
</ul>
<h3 id="提供接口"><a href="#提供接口" class="headerlink" title="提供接口"></a>提供接口</h3><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514222531059.png" alt="image-20240514222531059"></p>
<h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><ul>
<li>处理机管理：用于分配和控制处理机</li>
<li>存储器管理：负责内存的分配与回收</li>
<li>IO设备管理：负责IO设备的分配与操作</li>
<li>文件管理：用于实现对文件的存取、共享和保护</li>
</ul>
<p>实现资源共享的方式——<strong>多路复用</strong></p>
<hr>
<h3 id="资源抽象"><a href="#资源抽象" class="headerlink" title="资源抽象"></a>资源抽象</h3><p>抽象与现实，类似于类与实例</p>
<p>操作系统的抽象，是把硬件的具体细节隐藏了，而将一个清晰的、优雅的、一致的<strong>接口</strong>提供给用户。例如，CPU，鼠标等设备都被操作系统抽象成为了<strong>文件（数据结构）</strong>，用户通过命令来操作它们</p>
<p>linux一切皆文件.jpg：</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514223049739.png" alt="image-20240514223049739"></p>
<hr>
<h2 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h2><h3 id="集成电路和多道批处理"><a href="#集成电路和多道批处理" class="headerlink" title="集成电路和多道批处理"></a>集成电路和多道批处理</h3><h4 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h4><blockquote>
<p>单位时间内CPU使用情况的统计，是<strong>除了空闲时间外的其他时间占总 CPU 时间的百分比</strong></p>
</blockquote>
<p>因为只有所有进程都处于阻塞态（如等待I&#x2F;O）或者就绪队列中无进程时，CPU才会空闲下来，所以<code>CPU利用率 = 1 - 进程等待I/O的概率 * 进程数</code></p>
<h4 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h4><blockquote>
<p>满足用户对人机交互的需求，包括<strong>人机交互</strong>和<strong>共享主机</strong></p>
</blockquote>
<p>如Unix</p>
<p>特征：</p>
<ul>
<li>多路性：多台终端同时联接到一台主机上</li>
<li>独立性：用户在各自的终端上操作</li>
<li>及时性：短时间响应</li>
<li>交互性：广泛的人机对话</li>
</ul>
<p>应用程序可以交替执行</p>
<hr>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><p><strong>并发和共享</strong>是多用户OS最基本的特征，并发和共享互为存在条件</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li><p>并发性（concurrency）是指两个或多个事件在<strong>同一时间间隔内</strong>发生。在宏观上是同时发生的，在微观上却仍是交替发生的</p>
</li>
<li><p>并行性（parallel）是指两个或多个事件在<strong>同一时刻</strong>发生（多处理器才可能真正实现）</p>
</li>
</ul>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>系统中的资源可供<strong>内存中</strong>多个并发执行的<strong>进程</strong>共同使用，这里既限定了时间（进程在内存中时），又限定了地点（内存）</p>
<p>主要的实现方式有两种：</p>
<ol>
<li><p>互斥共享：规定一段时间内<strong>只允许一个进程访问</strong>该资源，仅当当前进程访问完并释放后，才允许另一进程对该资源进行访问</p>
<p>这种资源叫做<strong>临界资源</strong>，如系统中的大多数物理设备以及栈、变量和表格，都只能被互斥地共享</p>
</li>
<li><p>同时共享：允许一段时间内由多个进程“同时”对资源进行访问，这种资源比如有磁盘设备，允许若干个用户同时访问的文件</p>
</li>
</ol>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>在操作系统中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为“虚拟”</p>
<ol>
<li><p>时分复用：</p>
<ul>
<li>虚拟处理机技术：利用多道程序设计技术，为每道程序建立至少一个进程，使多道程序并发执行</li>
<li>虚拟设备技术：将一台物理上的 I&#x2F;O 设备虚拟为多台<strong>逻辑上</strong>的 I&#x2F;O 设备，并允许每个用户占用一台逻辑上的 I&#x2F;O 设备，这样便可使临界资源变为允许多个用户“同时”访问的共享设备</li>
</ul>
</li>
<li><p>空分复用：<strong>利用存储器的空闲空间（如某道程序阻塞时被换出到外存而空出来的内存空间）来存放其他程序</strong>以提高内存的利用率；还要引入<strong>虚拟存储技术</strong>（补充内存逻辑空间的技术），实现内存的<strong>分时复用</strong>，例如，100MB的程序在30MB的内存空间中可以运行是因为<strong>每次只把程序的一部分调入内存运行</strong></p>
</li>
</ol>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><blockquote>
<p>进程是以人们不可预知的速度向前推进的</p>
</blockquote>
<p>让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情</p>
<hr>
<h2 id="运行机制与体系结构"><a href="#运行机制与体系结构" class="headerlink" title="运行机制与体系结构"></a>运行机制与体系结构</h2><p>操作系统通过<strong>指令</strong>来运行处理器</p>
<ul>
<li>特权指令：具有高级别权限，不允许用户程序使用</li>
<li>非特权指令：普通级别权限，如加减乘除等运算指令</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>用户态：应用程序运行时所处的状态</p>
<p>内核态：操作系统内核运行时所处的状态</p>
<p>当应用程序需要访问操作系统提供的资源或执行一些特权操作时，需要切换到内核态，由操作系统内核来完成相应的操作。在内核态下，应用程序无法直接访问系统资源和硬件设备，需要通过操作系统提供的接口来进行操作</p>
<ul>
<li>用户态-&gt;内核态：通过<strong>中断</strong>&#x2F;异常&#x2F;陷入机制实现，且中断是唯一途径</li>
<li>内核态-&gt;用户态：通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”</li>
</ul>
<p>内核程序：操作系统中，可以访问所有硬件设备，如网卡、内存设备等的一些特殊的高权限的系统程序</p>
<p>用户程序：只能有限的访问部分内存空间，对硬件设备没有访问权限的低权限的应用程序或系统程序</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240630100751480.png" alt="image-20240630100751480"></p>
<hr>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><blockquote>
<p>事件总是由中断或异常（陷阱）引起的，现代OS是由中断驱动的</p>
</blockquote>
<p><strong>中断</strong>：CPU对系统发生的某个事件做出的某种反应。当系统接收到一个中断信号时，CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，完成后返回断点，继续执行被打断的程序</p>
<ul>
<li>中断的引入：为了支持CPU和设备间的并行操作（多道程序），即实现多道程序并发执行</li>
</ul>
<p><strong>异常</strong>：一种由<strong>软件引起</strong>的中断，或源于出错，或源于用户程序的特定请求（如执行OS的某个服务等）</p>
<ul>
<li>异常的引入：表示CPU执行指令时本身出现的问题。如运算中遇到除零等错误，此时硬件改变了CPU当前的执行流程，自动转到相应的错误处理程序或异常处理程序或执行系统调用</li>
</ul>
<p>分类：</p>
<ul>
<li><strong>内中断</strong>（也称异常、例外、陷入）：信号来源于CPU内部，与当前执行的指令有关<ul>
<li>自愿中断：指令中断，如系统调用时使用的访管指令（又叫陷入指令、trap指令）</li>
<li>强迫中断：硬件故障（如缺页）、软件中断（如整数除以0）</li>
</ul>
</li>
<li><strong>外中断</strong>：信号来源于CPU外部，与当前执行的指令无关<ul>
<li>外设要求：I&#x2F;O操作完成发出的中断信号</li>
<li>人工干预：用户强行终止一个进程</li>
</ul>
</li>
</ul>
<p>中断&#x2F;异常的作用：</p>
<ul>
<li>及时处理设备发来的中断请求</li>
<li>使操作系统能捕获用户程序提出的服务请求</li>
<li>防止用户程序执行过程中的破坏活动等</li>
</ul>
<p>发生中断就意味着需要操作系统介入，开展管理工作。由于操作系统的管理操作（如进程切换、分配IO设备等）需要使用特权指令，因此CPU要<strong>从用户态转为核心态</strong></p>
<hr>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>应用程序通过<strong>系统调用（陷入机制，由用户态-&gt;内核态）</strong>请求操作系统的服务</p>
<p>系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是<strong>与资源有关的操作（如存储分配、IO操作、文件管理等）</strong>，都必须通过<strong>系统调用</strong>的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的<strong>稳定性和安全性</strong>，防止用户进行非法操作</p>
<p>注：系统调用的处理是在<strong>核心态</strong>进行的</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514225028039.png" alt="image-20240514225028039"></p>
<p>实例：C语言read函数的调用</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">count <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> nbytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// fd：指定文件</span>
<span class="token comment">// buffer：指向缓冲区</span>
<span class="token comment">// nbytes：要读出的字节数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514225133792.png" alt="image-20240514225133792"></p>
<hr>
<h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><ul>
<li><p>单体系统（无结构系统）：整个操作系统在内核态以单一程序的方式运行。该结构中，系统中每个过程可以自由调用其他过程。整个系统以过程集合的方式编写，链接成一个大型可执行二进制程序</p>
</li>
<li><p>层次式系统：THE系统</p>
</li>
<li><p>微内核：将系统分成若干小的、良好定义的模块，且只有其中一个模块——<strong>微内核运行在内核态</strong>，其余模块则作为普通用户进程运行</p>
</li>
<li><p>客户端-服务器模式：微内核的一种变体，如Web服务器</p>
</li>
<li><p>虚拟机</p>
</li>
<li><p>外核</p>
</li>
</ul>
<hr>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="定义-amp-特征"><a href="#定义-amp-特征" class="headerlink" title="定义&amp;特征"></a>定义&amp;特征</h3><blockquote>
<p>进程是指在系统中能够<strong>独立运行</strong>并作为<strong>资源分配的基本单位</strong>，是由一组机器指令、数据和堆栈等组成的活动实体</p>
</blockquote>
<p>进程实体（进程映像，可以认为是进程）：由<strong>程序段、相关的数据段和PCB</strong>三部分构成，是静态的；进程是进程实体的运行过程，是动态的</p>
<p>进程的特征：</p>
<ol>
<li>动态性：进程的实质是程序的执行过程；而程序只是一组有序指令的集合，并存放在某种介质上</li>
<li>并发性：内存中有多个进程实体，各进程可并发执行</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li>异步性：各进程按各自独立的、不可预知的速度向前推进，系统提供<strong>同步机制</strong>来解决<strong>异步问题</strong></li>
</ol>
<hr>
<h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><ol>
<li><strong>进程也是一种程序</strong>，是专门负责处理其它程序如何在操作系统中运行的程序</li>
<li>进程能<strong>描述并发</strong>，而程序没有这个功能</li>
<li>进程是<strong>动态</strong>的，程序是<strong>静态</strong>的（根本区别）</li>
<li>进程有生命周期，是<strong>短暂的</strong>；而程序相对长（存在磁盘里）</li>
<li>一个程序可以对应多个进程（程序多开）</li>
<li>进程具有创建其它进程的功能</li>
</ol>
<hr>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><p>进程控制块（PCB）：操作系统配置的一个专门的数据结构。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程</p>
<p>PCB是<strong>进程存在的唯一标志</strong>。创建进程，实质上是<strong>创建进程实体中的PCB</strong>；而撤销进程，实质上是撤销进程实体中的PCB</p>
<p>PCB的构成：</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512163957084.png" alt="image-20240512163957084"></p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512164559547.png" alt="image-20240512164559547"></p>
<ul>
<li>标识符：与进程相关的唯一标识符，用来区分其他进程</li>
<li>状态：若进制正在执行，则进程处于运行态</li>
<li>优先级：相对于其他进程的优先顺序</li>
<li>程序计数器：程序中即将执行的下一条指令的地址</li>
<li>内存指针：包括程序代码和进程相关数据的指针，以及与其他进程共享内存块的指针</li>
<li>上下文数据：进程执行时处理器的寄存器中的数据</li>
<li>IO状态信息：包括显式IO请求，分配给进程的IO设备和被进程使用的文件列表等</li>
<li>记账信息：包括处理器时间总和，使用的时钟数总和，时间限制等</li>
</ul>
<p>组织方式：</p>
<ul>
<li><p><strong>线性方式</strong>：把所有的PCB都组织在一张线性表中，表的首地址存放在内存专用区</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512165350169.png" alt="image-20240512165350169"></p>
</li>
<li><p><strong>链接方式</strong>：把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列，如就绪队列。通常，将优先级高的进程排在前面</p>
<p>（图中最右边的指针表示队列中下一个优先级的PCB指针，0表示队列结束）</p>
<p>（注：单处理器系统中，同一时刻只有一个进程会处于运行状态）</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512165554956.png" alt="image-20240512165554956"></p>
<p>如果系统中有许多处于就绪状态的进程，通常将它们按一定的策略（如优先级）排队，称为<strong>就绪队列</strong></p>
<p>如果将处于阻塞状态的进程进行排队，称为<strong>阻塞队列</strong>。而为了减少队列操作的开销，系统会设置多个阻塞队列</p>
</li>
<li><p><strong>索引方式</strong>：系统根据所有进程状态，建立几张索引表，并把索引表的首地址记录在内存的专用单元中。在每个索引表中，记录具有相应状态的PCB在PCB表中的首地址</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512170205528.png" alt="image-20240512170205528"></p>
</li>
</ul>
<p>操作系统会提供一个唯一<strong>仲裁程序</strong>例程来保护PCB，这里涉及到系统性能、软件信任度等问题</p>
<hr>
<h4 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h4><blockquote>
<p>能被进程调度程序调度到CPU执行的程序代码段</p>
</blockquote>
<p>程序可以被多个进程共享，即多个进程可以运行同一个程序</p>
<hr>
<h4 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h4><p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果</p>
<p><code>.data</code>段：保存已初始化的全局变量和局部静态变量</p>
<p><code>.bss</code>段：保存未初始化的全局变量和未初始化的局部静态变量</p>
<hr>
<h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><p>父进程：创建进程的进程<br>子进程：被创建的进程，子进程又可以创建自己的子进程（即父进程的孙进程）。子进程可以继承父进程所拥有的资源，如父进程所打开的文件和分配到的缓冲区</p>
<p>Unix &#x2F; Linux 系统为树型结构，可以共同组成一个进程家族（进程组）</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512171035976.png" alt="image-20240512171035976"></p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512171113560.png" alt="image-20240512171113560"></p>
<p>Windows 系统没有进程层次的概念，所有进程都是地位相同的，进程之间的关系是获得句柄（作用相当于一个令牌，可以用来控制被创建的进程）与否、控制与被控制的关系</p>
<p>父进程使用<strong>句柄</strong>来控制子进程，然而，父进程可以把句柄传送给其它进程，这样就不存在进程层次了</p>
<hr>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><h4 id="基本状态与转换"><a href="#基本状态与转换" class="headerlink" title="基本状态与转换"></a>基本状态与转换</h4><p>3种基本状态：</p>
<ul>
<li><p><strong>就绪态</strong>（ready）：进程已处于可运行的状态，只要获得CPU资源，就可立即运行</p>
</li>
<li><p><strong>运行态</strong>（running）：该时刻进程实际占用CPU</p>
</li>
<li><p><strong>阻塞&#x2F;等待态</strong>（block&#x2F;waiting）：正在执行的进程由于发生某事件（如I&#x2F;O请求、申请缓冲区失败等）而暂时无法继续执行</p>
</li>
</ul>
<p>基本状态转换：三状态模型</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1711539242316.jpg" alt="1711539242316.jpg"></p>
<ol>
<li><strong>就绪-&gt;运行</strong>：调度程序选择一个新的进程运行</li>
<li><strong>运行-&gt;就绪</strong>：运行进程用完了时间片且被换出；一个高优先级进程抢占正在运行的进程</li>
<li><strong>运行-&gt;阻塞</strong>：当一个进程等待某个事件发生时，如I&#x2F;O请求</li>
<li><strong>阻塞-&gt;就绪</strong>：进程所等待的事件发生了，如I&#x2F;O操作完成，产生中断</li>
</ol>
<p>（不存在 阻塞态 -&gt; 运行态 ）</p>
<p>再认识两种状态：</p>
<ul>
<li>创建态（或称新建态，new）：进程正在被创建，操作系统为进程分配资源、初始化PCB</li>
<li>终止态（或称结束态，terminated）：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</li>
</ul>
<p>于是就有了五状态模型：</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240512172936740.png" alt="image-20240512172936740"></p>
<hr>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>是对系统中的所有进程实施有效的管理，具有<strong>进程创建</strong>、<strong>进程执行</strong>、<strong>进程切换</strong>以及<strong>进程终止（撤销）</strong>等功能</p>
<p>本质就是实现进程状态转换</p>
<p>一般由OS内核中的原语来实现：</p>
<ul>
<li>原语处于系统最底层，是最接近硬件的部分，运行事件较短、调用频繁。其最大的特点是执行期间<strong>不允许中断</strong>（即操作的原子性）</li>
<li>原语采用“关中断”和“开中断”指令实现。开关中断指令的权限很大，是运行在<strong>核心态下的特权指令</strong></li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>引起进程创建的事件：</p>
<ol>
<li>用户登录：系统初始化</li>
<li>作业调度：一个批处理作业的初始化</li>
<li>提供服务：正在运行的程序执行了<strong>创建进程的系统调用</strong></li>
<li>应用请求：用户请求创建一个新进程（上面3种都是由系统内核为用户创建一个新进程）</li>
</ol>
<p>启动操作系统时会创建若干个进程，一些是前端交互进程，一些是后端守护进程（daemon）</p>
<p>进程的创建：</p>
<ol>
<li>申请空白PCB</li>
<li>为新进程分配其运行所需的资源</li>
<li>初始化PCB</li>
<li>如果进程就绪队列能够接纳新进程，就将新进程插入就绪队列</li>
</ol>
<ul>
<li>通常，在系统调用<code>fork()</code>后，进程会使用另一个系统调用<code>exec()</code>，用新程序来取代进程的内存空间</li>
</ul>
<p>创建的一般步骤：</p>
<ol>
<li>为新进程分配一个唯一的进程标识符</li>
<li>为进程分配空间</li>
<li>初始化进程控制块</li>
<li>设置正确的链接：新进程进状态队列链表</li>
<li>创建或扩充其他数据结构：维护记账文件</li>
</ol>
<hr>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>处理器至少支持两种执行模式：特权模式和用户模式</p>
<ul>
<li>特权模式：也称为系统模式、控制模式或内核模式</li>
<li>用户模式：通常是用户程序运行的模式</li>
</ul>
<p>设计两种模式是为了保护操作系统和重要的操作系统表不受用户程序的干扰</p>
<p>系统通过程序状态字<code>PSW</code>来判断当前模式</p>
<hr>
<h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>进程的挂起：暂停运行</p>
<ul>
<li>终端用户的需要</li>
<li>父进程的请求</li>
<li>负荷调节的需要</li>
<li>操作系统的需要</li>
</ul>
<p>切换的时机：进程切换可在<strong>操作系统从当前正在运行进程中获得控制权的任何时刻</strong>发生，如一个进程从运行态切换为就绪态</p>
<ul>
<li>上下文（context）：进程执行时处理器的寄存器中的数据</li>
</ul>
<p>切换的成因：</p>
<ul>
<li>系统中断，如时钟中断、IO中断或者内存失效</li>
<li>操作系统确定出现错误或异常条件</li>
<li>系统调用，正运行用户进程执行了一个请求IO操作的指令，此时该调用会转移到作为系统代码一部分的一个例程</li>
</ul>
<p>切换的一般步骤：</p>
<ol>
<li>决定是否作切换以及是否允许作切换</li>
<li>保存当前进程的进程上下文（包括CPU的所有寄存器中的值、进程的状态以及堆栈中的内容）</li>
<li>更新当前处于运行态进程的PCB以及其他相关字段的更新，如退出运行态的原因和记账信息</li>
<li>把该进程的PCB移到相应的队列</li>
<li>使用进程调度算法，选择某个就绪状态的进程</li>
<li>更新所选进程的PCB</li>
<li>更新内存管理数据结构（切换新的页表，然后使用新的虚拟地址空间）</li>
<li>载入程序计数器和其他寄存器先前的值，将进程上下文恢复为所选进程上次退出运行态时的上下文</li>
</ol>
<hr>
<h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>事件：</p>
<ul>
<li><p>正常退出（自愿的）</p>
</li>
<li><p>出错退出（自愿的）：如打开不存在的文件，则系统会退出</p>
</li>
<li><p>严重错误（非自愿的）：指的是进程引起的错误，比如执行一条非法指令，引用不存在的内存或是除数为零等</p>
</li>
<li><p>被其他进程杀死（非自愿的）：Unix中的系统调用是<code>kill</code>，Windows中使用<code>TerminateProcess</code>函数</p>
</li>
</ul>
<hr>
<h3 id="阻塞与唤醒"><a href="#阻塞与唤醒" class="headerlink" title="阻塞与唤醒"></a>阻塞与唤醒</h3><p>事件：</p>
<ul>
<li>向系统请求共享资源失败</li>
<li>等待某种操作的完成</li>
<li>新数据尚未到达</li>
<li>等待新任务的到达</li>
</ul>
<hr>
<h2 id="进程通信（IPC）"><a href="#进程通信（IPC）" class="headerlink" title="进程通信（IPC）"></a>进程通信（IPC）</h2><p>指进程之间的信息交换</p>
<blockquote>
<p>进程是分配系统资源的单位（包括内存地址空间），因此各个进程拥有<strong>独立的内存地址空间</strong>，一个进程不能直接访问另一个进程的地址空间</p>
</blockquote>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="直接制约关系——相互合作"><a href="#直接制约关系——相互合作" class="headerlink" title="直接制约关系——相互合作"></a>直接制约关系——相互合作</h4><p>进程A通过缓冲区向进程B提供数据；当缓冲区空时，进程B不能获得数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒；反之，缓冲区满时，进程A被阻塞，仅当进程B取走数据时，才唤醒进程A（同步）</p>
<h4 id="间接制约关系——共享资源"><a href="#间接制约关系——共享资源" class="headerlink" title="间接制约关系——共享资源"></a>间接制约关系——共享资源</h4><p>进程A进入临界区访问临界资源，此时进程B必须等待，当进程A退出临界区，进程B才能进入临界区访问临界资源（互斥）</p>
<h4 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h4><p>系统中某些资源一次只允许一个进程使用，如系统中的大多数物理设备以及栈、变量和表格等</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><blockquote>
<p>各个进程中对某个<strong>临界资源</strong>实施操作的程序（代码）片段</p>
</blockquote>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240513231352172.png" alt="image-20240513231352172"></p>
<p>使用原则：</p>
<ol>
<li>空闲让进：没有进程在临界区时，想进入临界区的进程可以进入</li>
<li>忙则等待：不允许两个进程同时处于临界区中</li>
<li>让权等待：临界区外运行的进程不得阻塞其他进程进入临界区</li>
<li>有限等待：不得使进程无限期等待进入临界区</li>
</ol>
<hr>
<h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><p>是指为完成某种任务而建立的两个或多个进程，这些进程的执行存在某种时序关系，需要互相协作、合作</p>
<p>具体地，一个进程运行到某一个点时，要求另一个伙伴进程为它提供<strong>消息</strong>，在未获得消息之前，该进程进入<strong>睡眠（阻塞态）</strong>，获得消息后被<strong>唤醒</strong>进入<strong>就绪态</strong></p>
<hr>
<h4 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h4><blockquote>
<p>进程互斥指的是当一个进程访问某临界资源时，其他进程必须等待其释放之后才能去访问该资源（即互斥访问）</p>
</blockquote>
<p>进程互斥描述的是进程（对共享资源）的<strong>竞争关系</strong>；而进程同步描述的是进程（对共享资源）的<strong>合作关系</strong></p>
<p>互斥是同步的一种特殊情况</p>
<p>对临界资源的互斥访问：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
	entry section<span class="token punctuation">;</span> <span class="token comment">// 进入区，负责检查能否可进入的代码</span>
	critical section<span class="token punctuation">;</span> <span class="token comment">// 临界区，访问临界资源的代码</span>
	exit section<span class="token punctuation">;</span> <span class="token comment">// 退出区，负责解除对资源的占用的代码</span>
	remainder section<span class="token punctuation">;</span> <span class="token comment">// 剩余区，做其他处理的代码</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>true<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="进程通信方法"><a href="#进程通信方法" class="headerlink" title="进程通信方法"></a>进程通信方法</h3><p>进程的高级通信机制共有以下四种：</p>
<h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240513225504009.png" alt="image-20240513225504009"></p>
<ol>
<li>基于共享<strong>数据结构</strong>的通信方式：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方法</li>
<li>基于共享<strong>存储区</strong>的通信方式：在内存中划出一块存储区，数据的形式、存放位置都由进程控制，而不是OS。相比之下，速度快，是一种高级通信方式</li>
</ol>
<hr>
<h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><blockquote>
<p>管道： 指用于连接一个<strong>读进程</strong>和一个<strong>写进程</strong>以实现它们之间通信的一个共享文件，即pipe文件，其实就是在内存中开辟一个固定的缓冲区</p>
</blockquote>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240513225408966.png" alt="image-20240513225408966"></p>
<p>管道机制的协调能力：</p>
<ol>
<li>互斥：防止进程进入竞争条件</li>
<li>同步</li>
<li>确定对方是否存在</li>
</ol>
<hr>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240513225709634.png" alt="image-20240513225709634"></p>
<p>以<strong>格式化的消息</strong>为单位，将通信的数据封装在消息（队列）中，并利用系统提供的一组通信命令（原语）在进程间传递消息，完成进程间的数据交换。</p>
<p>例如：在计算机网络中，消息又被称为报文</p>
<p>该方法属于高级通信方式，主要方式：</p>
<ul>
<li><strong>直接通信方式</strong>：消息直接发送到接收进程的消息缓冲队列上</li>
<li><strong>间接通信方式</strong>：也称为信箱通信方式，消息要先发送到中间实体（信箱）中</li>
</ul>
<hr>
<h4 id="客户机－服务器"><a href="#客户机－服务器" class="headerlink" title="客户机－服务器"></a>客户机－服务器</h4><p>实现方法：</p>
<ul>
<li><p><strong>套接字</strong>：一个套接字就是一个通信标志类型的数据结构</p>
<ul>
<li><p>基于文件型：一个套接字关联一个特殊的文件，通信双方通过对这个特殊文件进行读&#x2F;写而实现通信，类似于前面的管道通信</p>
</li>
<li><p>基于网络型：通常是非对称方式通信，即发送者需要提供接收者的名称</p>
</li>
</ul>
</li>
<li><p><strong>远程过程调用（remote procedure call，RPC）</strong>和远程方法调用：RPC是一个通信协议，用于通过网络连接的系统，该协议允许运行于<strong>一台主机（本地）系统上的进程调用另一台主机（远程）系统上的进程</strong></p>
<p>如果涉及的软件采用面向对象编程，那么远程过程调用也可以称作<strong>远程方法调用</strong>，例子：Java中的RMI</p>
</li>
</ul>
<hr>
<h3 id="进程间的关系"><a href="#进程间的关系" class="headerlink" title="进程间的关系"></a>进程间的关系</h3><table>
<thead>
<tr>
<th>感知程度</th>
<th>关系</th>
<th>一个进程对其他进程的影响</th>
<th>潜在的控制问题</th>
</tr>
</thead>
<tbody><tr>
<td>进程间不知道对方的存在</td>
<td>竞争</td>
<td>一个进程的结果与另一个进程的活动无关；进程的执行时间可能会受到影响</td>
<td>互斥；死锁；饥饿</td>
</tr>
<tr>
<td>进程间接知道对方存在（共享对象）</td>
<td>共享合作</td>
<td>一个进程的结果可能取决于另一进程获得的信息；进程的执行时间可能会受到影响</td>
<td>互斥；死锁；饥饿；数据一致性</td>
</tr>
<tr>
<td>进程直接知道对方的存在（通信）</td>
<td>通信合作</td>
<td>一个进程的结果可能取决于另一进程获得的信息；进程的执行时间可能会受到影响</td>
<td>死锁；饥饿</td>
</tr>
</tbody></table>
<hr>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>原语：由若干条指令组成的，用于完成一定功能的一个过程，它们是<strong>原子操作</strong>；一个操作中的所有动作要么全做，要么全不做；<strong>原子性</strong>保证了并发进程的隔离</p>
<p>竞争条件：两个或多个进程读写某些共享数据，且最后的结果取决于这些进程运行的精确时序</p>
<p>互斥：由于各进程要求使用共享资源（变量、文件等），而这些资源需要排他性使用（独占），各进程之间竞争使用这些资源的关系</p>
<hr>
<hr>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>一组进程中，每个进程都<strong>无限等待</strong>被该组进程中另一进程所占有的资源，因而永远无法得到的资源。即大家都占用着对方想要的资源</p>
<p>活锁：拿到资源却又相互释放不执行</p>
<hr>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个可运行进程尽管能继续执行，但被调度程序无限期地忽视，而不能被调度执行的情形</p>
<p>例子：</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">如打印机分配案例。一种可能的方案是把打印机分配给打印最小文件的进程。
如果在一个繁忙的系统中，某个进程有一个很大的文件要打印，这个进程可能永远得不到打印机。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<hr>
<h2 id="互斥访问的实现方法"><a href="#互斥访问的实现方法" class="headerlink" title="互斥访问的实现方法"></a>互斥访问的实现方法</h2><h3 id="软件解法"><a href="#软件解法" class="headerlink" title="软件解法"></a>软件解法</h3><p>单标志法（严格轮换）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">global boolean free <span class="token operator">=</span> false <span class="token comment">// 临界区空闲标志，true为有进程在临界区，false反之</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>进程P、Q：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>free<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 忙等待</span>
free <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">// lock()</span>
<span class="token comment">// 临界区</span>
free <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// unlock()</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>单标志轮换法</p>
<p>进程P：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>not turn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区</span>
turn <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进程Q：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>turn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区</span>
turn <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>双标志法</p>
<p>进程P：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
pturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>qturn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区</span>
pturn <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进程Q：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
qturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>pturn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区</span>
qturn <span class="token operator">=</span> false<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>违反了有限等待</p>
<h4 id="Dekker解法——三标志法"><a href="#Dekker解法——三标志法" class="headerlink" title="Dekker解法——三标志法"></a>Dekker解法——三标志法</h4><p>进程P：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
pturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>qturn<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        pturn <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        pturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// 临界区</span>
turn <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
pturn <span class="token operator">=</span> false
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进程Q：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
qturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>pturn<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        qturn <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        qturn <span class="token operator">=</span> true<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
    <span class="token comment">// 临界区</span>
turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
pturn <span class="token operator">=</span> false
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Peterson解法"><a href="#Peterson解法" class="headerlink" title="Peterson解法"></a>Peterson解法</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FALSE</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TRUE</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">2</span></span></span>
<span class="token keyword">int</span> turn<span class="token punctuation">;</span>
    <span class="token keyword">int</span> interested<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 兴趣数组，初始值均为FALSE</span>
    
<span class="token keyword">void</span> <span class="token function">enter_region</span><span class="token punctuation">(</span><span class="token keyword">int</span> process<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> other<span class="token punctuation">;</span>
    other <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> process<span class="token punctuation">;</span>
    interested<span class="token punctuation">[</span>process<span class="token punctuation">]</span> <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>
    turn <span class="token operator">=</span> process<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">==</span> process <span class="token operator">&amp;&amp;</span> interested<span class="token punctuation">[</span>other<span class="token punctuation">]</span> <span class="token operator">==</span> TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">leave_region</span><span class="token punctuation">(</span><span class="token keyword">int</span> process<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    interested<span class="token punctuation">[</span>process<span class="token punctuation">]</span> <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>进程i：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">enter_region</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 临界区</span>
<span class="token function">leave_region</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="硬件解法"><a href="#硬件解法" class="headerlink" title="硬件解法"></a>硬件解法</h3><p>开关中断</p>
<p>TSL（Test and Set Lock）指令</p>
<p>XCHG指令（或Swap交换指令）</p>
<hr>
<h2 id="进程同步-1"><a href="#进程同步-1" class="headerlink" title="进程同步"></a>进程同步</h2><p>允许多个进程从临界区里读数据，仅是读不写</p>
<p>同步机制：信号量机制和管程机制</p>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><blockquote>
<p>两个或多个进程通过简单的信号进行合作，可以强迫一个进程在某个位置停止，直到它接收到一个特定的信号</p>
</blockquote>
<p>信号量：可以是一个整数，也可以是更复杂的记录型变量</p>
<p>用户进程通过使用操作系统提供的一对<strong>原语（P、V操作）</strong>对信号量进行操作，从而实现进程的互斥、同步</p>
<p>对信号量S可以实施的操作：初始化、P操作和V操作</p>
<p>初始化完成后，只有P、V操作才能改变其值</p>
<ul>
<li><p><code>P(s)/wait(s)</code>：s–（<strong>申请</strong>），若 s&lt;0 则等待，否则继续（这里的s是<strong>记录型变量</strong>）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">P</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// down, semWait</span>
<span class="token punctuation">&#123;</span>
    s<span class="token punctuation">.</span>count <span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">/*
        该进程状态置为阻塞状态;
        将该进程插入相应的等待队列s.quene末尾;
        重新调度;
        */</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>V(s)/signal(s)</code>：s++（<strong>释放</strong>），若 s&lt;&#x3D;0 ，唤醒一个等待的P</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">V</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">// up, semSignal</span>
<span class="token punctuation">&#123;</span>
    s<span class="token punctuation">.</span>count <span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">/*
        唤醒相应等待队列s.quene中等待的一个进程;
        改变其状态为就绪态，并将其插入就绪队列;
        */</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<ol>
<li><p>整型信号量：wait相当于P，signal相当于V，表示系统中某种资源的数量，如某系统中有一台打印机</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">wait</span> <span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// wait 原语（不能被中断，比如下面的S&lt;=0和S=S-1都不能被中断）相当于“进入区”</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>S <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果资源数不够，就一直循环等待（问题：只要S&lt;=0，就会发生“忙等”，违反“让权等待”原则）</span>
    S<span class="token operator">=</span>S<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 如果资源数够，则占用一个资源</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">signal</span> <span class="token punctuation">(</span><span class="token keyword">int</span> S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    S<span class="token operator">=</span>S<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>记录型信号量：用记录型数据结构表示。先分资源，然后分不到的就阻塞，释放一个资源的时候如果对资源还有需求则唤醒一个阻塞的进程</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>	<span class="token comment">// 代表资源数目</span>
    <span class="token keyword">struct</span> <span class="token class-name">process_control_block</span> <span class="token operator">*</span>list<span class="token punctuation">;</span>	<span class="token comment">// 进程链表指针，用于链接上述所有等待进程</span>
<span class="token punctuation">&#125;</span>semaphore<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>相应地，wait(S) 和 signal(S) 操作为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">wait</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    S<span class="token operator">-></span>value<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>value<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>	<span class="token comment">// 表示该类资源已分配完毕</span>
        <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token operator">-></span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 阻塞，并将该进程插入信号量链表中</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">signal</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    S<span class="token operator">-></span>value<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>value<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>	<span class="token comment">// 表示依然有进程在等待该类资源，因此调用wakeup原语唤醒等待队列中的第一个进程（由阻塞态进入就绪态）</span>
        <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token operator">-></span>list<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果 S-&gt;value 的初值为1，则表示只允许一个进程访问临界资源，此时的信号量是互斥信号量，用于进程互斥</p>
</li>
<li><p>AND型信号量：将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它可分配的资源也不分配给该进程。从而避免死锁</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">Swait</span><span class="token punctuation">(</span>Dmutex<span class="token punctuation">,</span> Emutex<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Dmutex <span class="token operator">>=</span><span class="token number">1</span> and Emutex <span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            Dmutex<span class="token operator">--</span><span class="token punctuation">;</span>
            Emutex<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    	<span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// 将该进程置入等待队列</span>
        <span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">Ssignal</span><span class="token punctuation">(</span>Dmutex<span class="token punctuation">,</span> Emutex<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        Dmutex<span class="token operator">++</span><span class="token punctuation">;</span>
        Emutex<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">// 将资源全部分给等待队列中的进程使其进入就绪态</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>信号量集：对AND信号量加以扩充，在每次分配前，都必须测试资源的数量，看是否大于其下限值，并可按要求一次性分配多个资源</p>
</li>
</ol>
<hr>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>实现进程互斥：</p>
<ul>
<li>设置互斥信号量<code>mutex</code>，初值为1</li>
<li>在临界区之前执行P操作</li>
<li>在临界区之后执行V操作</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">semaphore mutex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    临界区代码段<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>

<span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    临界区代码段<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
   	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意：对不同的临界资源需要设置不同的互斥信号量。PV操作必须成对出现</p>
<p>实现进程同步：</p>
<ul>
<li>分析发生“同步关系”的位置</li>
<li>设置同步信号量S，初始为0</li>
<li>在前操作之后执行V操作</li>
<li>在后操作之后执行P操作</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">semaphore S<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>

<span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    代码<span class="token number">1</span><span class="token punctuation">;</span>
    代码<span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    代码<span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
    代码<span class="token number">4</span><span class="token punctuation">;</span>
    代码<span class="token number">5</span><span class="token punctuation">;</span>
    代码<span class="token number">6</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>实现前驱关系：</p>
<ul>
<li>要为每一对前驱关系各设置一个同步变量</li>
<li>在前操作之后对相应的同步变量执行V操作</li>
<li>在后操作之前对相应的同步变量执行P操作</li>
</ul>
<hr>
<h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><p>高级同步机制：管程（monitor，Java中称为监视器，对应的关键字为<code>synchronized</code>），不用关注复杂的PV操作</p>
<p>管程是一个特殊（软件）模块，包括对描述共享资源的数据结构以及对该结构的操作的一组过程（即函数）</p>
<p>基本特征：</p>
<ul>
<li>管程中的数据只能被管程中的过程访问；</li>
<li>一个进程仅通过调用管程内的进程才能进入管程访问共享数据；</li>
<li>管程是互斥进入的，每次仅<strong>允许一个进程</strong>在管程内执行某个内部过程</li>
</ul>
<p>语法描述：</p>
<ul>
<li>管程的名字</li>
<li>变量（初始值）</li>
<li>一组过程</li>
</ul>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>设置<strong>条件变量（condition），等待（wait）&#x2F;唤醒（signal）</strong>操作来解决同步问题</p>
<ul>
<li>条件变量：管程内的等待机制<ul>
<li>进入管程的进&#x2F;线程因资源被占用而进入等待状态</li>
<li>每个条件变量表示一种等待原因，对应一个等待队列</li>
</ul>
</li>
<li>wait()：<ul>
<li>将自己阻塞在等待队列</li>
<li>唤醒一个等待者或释放管程的互斥访问</li>
</ul>
</li>
<li>signal()：<ul>
<li>将等待队列中的一个进&#x2F;线程唤醒</li>
<li>如果等待队列为空，则等同空操作</li>
</ul>
</li>
</ul>
<hr>
<h3 id="经典IPC问题"><a href="#经典IPC问题" class="headerlink" title="经典IPC问题"></a>经典IPC问题</h3><h4 id="生产者－消费者问题"><a href="#生产者－消费者问题" class="headerlink" title="生产者－消费者问题"></a>生产者－消费者问题</h4><p>问题描述：</p>
<ol>
<li>一个或多个生产者生成某种类型的数据放置在缓冲区中</li>
<li>有消费者<strong>从缓冲区中取数据，每次取一项</strong></li>
<li><strong>只能有一个生产者</strong>对缓冲区进行操作</li>
</ol>
<p>要解决的问题：</p>
<ol>
<li>当<strong>缓冲区已满</strong>时，生产者不会继续向其中添加数据</li>
<li>当<strong>缓冲区为空</strong>时，消费者不会从中移走数据</li>
</ol>
<p>正确性要求：</p>
<ul>
<li>在任何一个时间只能有一个线程操作缓冲区（互斥）</li>
<li>当缓冲区为空，消费者必须等待生产者（同步）</li>
<li>当缓冲区满，生产者必须等待消费者（同步）</li>
<li>需要三个信号量（每个要求需要一个单独的信号量）：二进制信号量mutex；一般信号量fullBuffers；一般信号量emptyBuffers</li>
</ul>
<p>初始化：设开始时buffer为空，生产者可以往buffer添加n个单位</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Class BoundedBuffer<span class="token punctuation">&#123;</span>
    mutex <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fullBuffers <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    emptyBuffers <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>生产者：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">BoundedBuffer<span class="token operator">::</span><span class="token function">Deposit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    emptyBuffers<span class="token operator">-></span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生产</span>
    mutex<span class="token operator">-></span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Add c to the buffer<span class="token punctuation">;</span>
    mutex<span class="token operator">-></span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// mutex的PV操作保证互斥</span>
    fullBuffers<span class="token operator">-></span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 有货，来取</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>消费者：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">BoundedBuffer<span class="token operator">::</span><span class="token function">Remove</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    fullBuffers<span class="token operator">-></span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 消费</span>
    mutex<span class="token operator">-></span><span class="token function">P</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Remove c from the buffer<span class="token punctuation">;</span>
    mutex<span class="token operator">-></span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// mutex的PV操作保证互斥</span>
    emptyBuffers<span class="token operator">-></span><span class="token function">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 空仓，生产</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h4 id="多生产者－多消费者问题"><a href="#多生产者－多消费者问题" class="headerlink" title="多生产者－多消费者问题"></a>多生产者－多消费者问题</h4><p>案例：桌上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子等着吃盘子中的橘子，女儿等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取水果</p>
<p>分析：</p>
<ul>
<li>互斥关系：盘子是共享资源，访问需要互斥</li>
<li>同步关系：父亲－&gt;女儿；母亲－&gt;儿子。“盘子为空”这个事件可由儿子或女儿触发，事件发生后才允许父亲或母亲放水果。</li>
</ul>
<p>设计：</p>
<p>互斥关系：对盘子的互斥访问，初值为 mutex&#x3D;1</p>
<p>同步关系：同步信号量的初始值要看对应资源的初始值是多少（这里apple&#x3D;0，orange&#x3D;0）盘子容量的初始值为plate&#x3D;1</p>
<hr>
<h4 id="读者－写者问题"><a href="#读者－写者问题" class="headerlink" title="读者－写者问题"></a>读者－写者问题</h4><p>多个进程共享一个数据区，这些进程分为两组：</p>
<ul>
<li>读者进程：只在数据区中读数据，不会清空数据</li>
<li>写者进程：只往数据区中写数据</li>
</ul>
<p>要求：</p>
<ul>
<li><strong>允许多个读者</strong>同时执行读操作（读进程不排斥其他读进程）</li>
<li><strong>不允许多个写者</strong>同时操作</li>
<li><strong>不允许读者、写者同时操作</strong>（写进程排斥其他所有进程）</li>
</ul>
<p>问题分析：</p>
<ul>
<li>互斥关系：写－写、读－读</li>
<li>同步关系：（即上面的要求）</li>
</ul>
<h5 id="解法一：读者优先"><a href="#解法一：读者优先" class="headerlink" title="解法一：读者优先"></a>解法一：读者优先</h5><p>如果读者执行：</p>
<ul>
<li>无其他读者、写者，该读者可以读</li>
<li>若已有写者等，但有其他读者正在读，则该读者也可以读</li>
<li>若有写者正在写，该读者必须等</li>
</ul>
<p>如果写者执行：</p>
<ul>
<li>无其他读者、写者，该写者可以写</li>
<li>若有读者正在读，该写者等待</li>
<li>若有其他写者正在写，该写者等待</li>
</ul>
<p>初始化</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">rw <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用于实现对文件的读写互斥访问</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 记录当前有几个读者在访问文件</span>
mutex <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 用于保证对count变量的互斥访问</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>


<p>读者：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证各读者互斥</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 第一个读者读</span>
            <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻止写进程</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 读者计数器加1</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        读文件
        
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证各读者互斥</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 读者计数器减1</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//当最后一个读者读完文件</span>
            <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 允许写进程</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>写者：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
         <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 互斥访问</span>
         
         写文件
         
         <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放资源</span>
         
         <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>问题：当不断有读者进来，那么写者就一直被阻塞等待，可能产生“饥饿”</p>
<hr>
<h5 id="解法二：写者优先"><a href="#解法二：写者优先" class="headerlink" title="解法二：写者优先"></a>解法二：写者优先</h5><p>保证一个写进程声明想写时，不允许新的读进程访问该数据区</p>
<p>初始化</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">rw <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于实现对文件的读写互斥访问</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前有几个读者在访问文件</span>
mutex <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 用于保证对count变量的互斥访问</span>
w <span class="token operator">=</span> new <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于保证写优先</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>读者</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在无写者请求时进入</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证各读者互斥</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 第一个读者读</span>
            <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻止写进程</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 读者计数器加1</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 恢复对文件的访问</span>
        
        读文件
        
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证各读者互斥</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 读者计数器减1</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 当最后一个读者读完文件</span>
            <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 允许写进程</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>写者</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
         <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 互斥访问</span>
         
         写文件
         
         <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 释放资源</span>
         
         <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>并发执行P(w)的情况：</p>
<p>读者1-&gt;读者2</p>
<p>写者1-&gt;写者2</p>
<p>写者1-&gt;读者1</p>
<p>读者1-&gt;写者1-&gt;读者2</p>
<p>写者1-&gt;读者1-&gt;写者2</p>
<hr>
<h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>场景：5个哲学家，5把叉子，5盘意大利面（需要两把叉子才能吃）。哲学家的活动方式为：要么放下左右手叉子进行思考，要么拿起刀叉开始吃饭，且只有者两种交替状态</p>
<p>问题分析：</p>
<ul>
<li>关系分析：5个哲学家，每个与左右邻居对其中间的叉子的访问是互斥关系</li>
<li>整理思路：每个哲学家需要同时持有两个临界资源才能开始吃饭，<strong>如何避免出现死锁现象</strong>是关键</li>
<li>信号量：定义5把叉子的信号量数组<code>&#123;1,1,1,1,1&#125;</code>，哲学家（0~4）i左边的叉子编号为i，右边的为<code>(i+1)%5</code></li>
</ul>
<hr>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote>
<p>是一个处理器调度和资源分配的<strong>基本单元</strong>，也是程序执行流的最小单位，可以理解为“轻量级进程”</p>
</blockquote>
<p>每个线程都有一个线程ID、线程控制块（TCB）</p>
<p>引入线程后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务</p>
<p>多线程：指操作系统在单个进程内支持多个并发执行路径的能力</p>
<p>执行路径：即处理器执行指令的执行顺序</p>
<h3 id="与进程的区别"><a href="#与进程的区别" class="headerlink" title="与进程的区别"></a>与进程的区别</h3><p>进程中<strong>所有线程共享该进程的状态和资源，所有线程都驻留在同一地址空间中，并可访问相同的数据</strong></p>
<ol>
<li>调度的基本单位：无线程操作系统中，进程作为独立调度和分派的基本单位，在每次被调度时，都需要进行<strong>上下文切换</strong>，开销大；有线程操作系统中，线程作为调度和分派的基本单位。当线程切换时，仅需<strong>保存和设置少量寄存器内容</strong>，切换代价远低于进程，且在同一进程中，线程的切换不会引起进程的切换</li>
<li>并发性：在引入线程的操作系统中，不仅<strong>进程之间</strong>可以并发执行，而且在<strong>一个进程中的多个线程之间</strong>亦可并发执行。<strong>不同进程间的线程</strong>也能并发执行。从而有效地提高系统资源的利用率和吞吐量</li>
<li>拥有资源：<strong>进程可以拥有资源</strong>，而<strong>线程本身并不拥有资源</strong>，而仅有一些必要的、能保证独立运行的资源。<strong>多个线程共享进程所拥有的资源</strong></li>
<li>独立性：在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多</li>
<li>系统开销：线程轻量级，开销小</li>
<li>支持多处理机</li>
</ol>
<hr>
<h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>类似于进程，线程也具有执行状态，且可彼此同步</p>
<p>线程状态：和进程一样，线程的主要状态有运行态、就绪态和阻塞态</p>
<p>与线程状态改变相关的操作：</p>
<ul>
<li>派生：在派生一个新进程时，同时也会为该进程派生一个线程。随后，进程中的线程可在同一个进程中派生另一个线程，并为新线程提供指令指针和参数；新线程拥有自己的寄存器上下文和栈空间，并放在就绪队列中</li>
<li>阻塞：线程需要等待一个事件时会被阻塞（保存线程的用户寄存器、程序计数器和栈指针），处理器转而执行另一个就绪线程</li>
<li>解除阻塞</li>
<li>结束：一个线程完成后会释放其寄存器上下文和栈</li>
</ul>
<hr>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>用户级线程（User-Level Thread, ULT）：由应用程序通过线程库实现，所有的线程<strong>管理工作都由应用程序负责</strong>（包括线程切换）</p>
<p>内核级线程（Kernel-Level Thread, KLT）：<strong>管理工作由操作系统内核完成</strong>，包括线程调度、切换等，因此内核级线程的切换必须在<strong>核心态</strong></p>
<hr>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>实质上是一种资源分配</p>
<h2 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h2><p>WHAT：调度算法</p>
<p>WHEN：调度时机</p>
<p>HOW：进程</p>
<hr>
<h2 id="调度概念"><a href="#调度概念" class="headerlink" title="调度概念"></a>调度概念</h2><h3 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h3><p>典型事件：</p>
<ul>
<li><strong>创建、唤醒、退出</strong>等进程控制操作</li>
<li><strong>进程等待IO、IO中断</strong></li>
<li><strong>时钟中断</strong>，如时间片用完，计时器到时</li>
<li>进程执行过程中出现abort异常</li>
</ul>
<p>当内核对中断&#x2F;异常&#x2F;系统调用做出处理时都是<strong>调度时机</strong></p>
<hr>
<h3 id="调度过程（进程切换）"><a href="#调度过程（进程切换）" class="headerlink" title="调度过程（进程切换）"></a>调度过程（进程切换）</h3><p>进程切换的代价：开销（cost）</p>
<ul>
<li>直接开销：内核完成切换所用的CPU时间，包含保存和恢复寄存器、切换地址空间（相关指令比较昂贵）</li>
<li>间接开销：高速缓存（Cache）失效、缓冲区缓存失效和TLB（快表）失效</li>
</ul>
<p>场景：进程A下CPU，进程B上CPU</p>
<ol>
<li>保存进程A的上下文环境（程序计数器、程序状态字、其他寄存器等）</li>
<li>用新状态和其他相关信息更新进程A的PCB</li>
<li>把进程A移至合适的队列（就绪、阻塞等）</li>
<li>将进程B的状态设置为运行态</li>
<li>从进程B的PCB中恢复上下文</li>
</ol>
<hr>
<h3 id="调度层次"><a href="#调度层次" class="headerlink" title="调度层次"></a>调度层次</h3><p><strong>长程调度</strong>（作业调度、高级调度）：对象是作业。根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列（外存与内存之间的调度，每个作业只调入一次，调出一次）</p>
<p>注：进程挂起时会被调到外存，但PCB不会被调到外存</p>
<p><strong>中程调度</strong>（内存调度、中级调度）：决定将哪个处于挂起状态的进程重新调入内存</p>
<p><strong>短程调度</strong>（进程调度、低级调度）：对象是进程（或LWP）。根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514211512314.png" alt="image-20240514211512314"></p>
<hr>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>进程优先级：表示进程的重要性和紧迫性</p>
<p>优先数：表示优先级的一个数值</p>
<p>静态优先级：在创建进程时确定的，其在进程的整个运行期间保持不变</p>
<p>动态优先级：在创建进程之初，先赋予进程一个优先级，然后优先级会随进程的推进或等待时间的增加而改变，以便获得更好的调度性能</p>
<p>抢占式：当有比正在运行的进程优先级更高的进程就绪时，系统可强行剥夺正在运行进程的CPU，提供给具有更高优先级的进程使用</p>
<p>非抢占式：继续运行</p>
<p>时间片：是一个时间段，分配给调度上CPU的进程，确定了允许该进程运行的时间长度</p>
<hr>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul>
<li><p>CPU利用率：指cpu的有效工作时间占总时间的比例</p>
</li>
<li><p>系统吞吐量：单位时间内完成作业的数量 &#x3D; <code>作业数 / 时间</code></p>
</li>
<li><p>到达时间（提交时间）：操作系统开始处理进程的时间点，之后进程进入队列等待被处理</p>
</li>
<li><p>开始时间：操作系统真正开始处理进程的时间点</p>
</li>
<li><p>执行时间：操作系统处理完这个程序的时间</p>
</li>
<li><p>周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔</p>
<p><code>周转时间 = 作业完成时间（结束时间） - 作业提交时间（到达时间）</code></p>
<p><code>平均周转时间 = 各作业周转时间之和 / 作业数</code></p>
<p><code>带权周转时间 = 作业周转时间 / 作业实际运行的时间（执行时间）</code></p>
</li>
<li><p>等待时间（响应时间）：指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低</p>
<p><code>等待时间 = 开始时间 - 到达时间</code></p>
</li>
</ul>
<hr>
<h3 id="多道批处理系统的调度算法"><a href="#多道批处理系统的调度算法" class="headerlink" title="多道批处理系统的调度算法"></a>多道批处理系统的调度算法</h3><p>做题时先画个甘特图再画表</p>
<ul>
<li><p>先来先服务（FCFS）：<strong>先进先出</strong>（FIFO），非抢占式算法</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240629173343102.png" alt="image-20240629173343102"></p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240629172232461.png" alt="image-20240629172232461"></p>
</li>
<li><p>最短作业优先（SJF）：在有多个进程在队列中等待处理时，具有<strong>最短完成时间的进程优先执行</strong>，即要求服务时间最短</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240629173420418.png" alt="image-20240629173420418"></p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240629172651663.png" alt="image-20240629172651663"></p>
</li>
<li><p>最短剩余时间优先（SRTN）：SJF抢占式版本，<strong>当一个新就绪的进程比当前运行进程具有更短的完成时间，系统抢占当前进程</strong>，选择新就绪的进程执行</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240629172920710.png" alt="image-20240629172920710"></p>
</li>
<li><p>最高响应比优先（HRRN）：考虑到各个作业的等待时间，也能兼顾运行时间。计算响应比R，选择R最高的进程执行：</p>
<p><code>响应比R = 周转时间 / 执行时间 = （执行时间 + 等待时间）/ 执行时间 = 1 + （等待时间 / 执行时间） </code></p>
<p>满足短作业优先且不会发生饥饿现象</p>
</li>
</ul>
<hr>
<h3 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h3><ul>
<li><p><strong>轮转调度</strong>（RR）：轮流让各个进程执行一个时间片，用完时间片但是未执行完则被中断，重新放到<strong>就绪队列</strong>队尾排队（就绪状态）</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514215631657.png" alt="image-20240514215631657"></p>
<p>不可能导致饥饿现象</p>
</li>
<li><p>最高优先调度（HPF）：选择优先级最高的进程投入运行。通常<strong>系统进程优先级高于用户进程</strong>；<strong>前台进程优先级高于后台进程</strong>；操作系统更偏好IO型进程</p>
</li>
<li><p>多级队列调度（MQ）</p>
</li>
<li><p>多级反馈队列（MFQ）</p>
</li>
</ul>
<p>时间片问题：</p>
<ul>
<li>如果时间片太长（长于典型的交互时间）：降级为先来先服务算法，延长短进程的相应时间</li>
<li>如果时间片太短（短于典型的交互时间）：进程频繁切换浪费CPU时间</li>
</ul>
<hr>
<h3 id="实时系统调度算法"><a href="#实时系统调度算法" class="headerlink" title="实时系统调度算法"></a>实时系统调度算法</h3><p>硬实时系统：要求在指定的时间内必须完成任务</p>
<p>软实时系统：要求在指定的时间内尽量完成任务</p>
<ul>
<li><p>最早截止时间优先算法（EDF）：根据<strong>任务的截止时间</strong>确定任务的优先级。任务的截止时间越早，其优先级越高</p>
</li>
<li><p>最低松弛度优先（LLF）：根据<strong>任务的紧急或松弛程度</strong>来确定优先级。松弛度最低的优先级最高</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">例如，1个任务要在200ms时必须完成，其本身的执行时间为100ms，则松弛度为100ms；1个任务要在400ms时完成，其本身的执行时间为150ms，则松弛度为250ms<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<hr>
<h2 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h2><h3 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h3><p>定义：一组进程中，每个进程都<strong>无限等待</strong>被该组进程中另一进程所占有的资源，因而永远无法得到的资源，这种现象称为<strong>进程死锁</strong>，这一组进程就称为<strong>死锁进程</strong></p>
<p>参与死锁的进程是被阻塞的，无法上CPU</p>
<p>活锁：先加锁，再轮询。既无进展也无阻塞。能上CPU，但只能忙等</p>
<p>饥饿：长期得不到想要的资源，而无法上CPU</p>
<p>产生死锁的必要条件：</p>
<ul>
<li>互斥使用：一个资源每次只能给一个进程使用</li>
<li>占有且等待：进程在申请新的资源的同时保持对原有资源的占有</li>
<li>不可抢占：资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放</li>
<li>循环等待（环路等待）</li>
</ul>
<p>死锁发生时，以上四个条件一定是<strong>同时满足</strong>的，如果其中任何一个条件不成立，死锁就不会发生</p>
<p>注：<strong>发生死锁时一定有循环等待，但是发生循环等待时未必有死锁</strong></p>
<hr>
<h3 id="死锁建模"><a href="#死锁建模" class="headerlink" title="死锁建模"></a>死锁建模</h3><ul>
<li>圆形：进程节点</li>
<li>方形：资源节点</li>
<li>从资源节点到进程节点的有向边：该资源已被请求、授权并被进程占用</li>
<li>从进程节点到资源节点的有向边：当前进程正在请求该资源，并且该进程已被阻塞，处于等待状态</li>
</ul>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514220409361.png" alt="image-20240514220409361"></p>
<hr>
<h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h3><ul>
<li>忽略该问题</li>
<li>避免死锁：仔细分配资源，动态地避免死锁</li>
<li>预防死锁：通过破坏引起死锁的4个必要条件之一，防止死锁的发生</li>
<li>检测死锁并恢复（解除）：让死锁发生，检测它们是否发生，一旦发生，采取行动解决</li>
</ul>
<h4 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h4><p>假装无事发生</p>
<hr>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><blockquote>
<p>在系统运行过程中，对进程请求的资源进行动态检查，并根据检查结果决定是否分配资源，若分配后系统发生死锁或可能发生死锁，则不予分配，否则予以分配</p>
</blockquote>
<p>考虑一个系统，它有<strong>固定数量的进程和固定数量的资源</strong>，任何时刻一个进程可能分配到零个或多个资源</p>
<ul>
<li>安全序列：如果系统按照这种序列分配资源，则所有进程都能顺利完成。只要能找出一个安全序列，系统就处于<strong>安全状态</strong>。<strong>安全序列可能有多个</strong></li>
<li>不安全状态：如果分配资源后，系统找不出任何一个安全序列，则系统进入<strong>不安全状态</strong>。当然，如果有进程提前归还了一些资源，则系统有可能重新回到安全状态</li>
</ul>
<p>系统处于安全状态，就一定不会发生死锁；如果系统进入不安全状态，就有可能发生死锁。处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态</p>
<p>两个状态的区别：从安全状态出发，系统能保证所有进程都能完成；而从不安全状态出发，就无法保证</p>
<h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><blockquote>
<p>在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会，就暂时不答应这次请求，让该进程先阻塞等待</p>
</blockquote>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240514221633301.png" alt="image-20240514221633301"></p>
<p>检查一个状态是否安全的算法：</p>
<ul>
<li><p>查找右边矩阵中是否有一行，其<strong>没有被满足的资源数均小于等于A</strong>。如果不存在，那么系统将会死锁，因为任何进程都无法运行结束</p>
</li>
<li><p>假如找到这样一行，那么可以假设它获得所需的资源并运行结束，将该进程标记为终止，<strong>并将其资源加到向量A上</strong></p>
</li>
<li><p>重复以上两步，或者直到所有的进程都标记为终止，其初始状态是安全的；反之，发生死锁</p>
</li>
</ul>
<hr>
<h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><ol>
<li>破坏互斥条件：一般来说无法破坏</li>
<li>破坏占有且等待条件：</li>
<li>破坏不可抢占条件：当一个进程请求当前被另一个进程占有的一个资源时，操作系统可以抢占另一个进程，要求它释放资源</li>
<li>破坏循环等待条件：采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源</li>
</ol>
<hr>
<h4 id="死锁检测和死锁恢复"><a href="#死锁检测和死锁恢复" class="headerlink" title="死锁检测和死锁恢复"></a>死锁检测和死锁恢复</h4><p>死锁检测</p>
<p>死锁恢复：</p>
<ol>
<li>利用抢占恢复</li>
<li>利用回滚恢复：设置进程检查点</li>
<li>通过杀死进程恢复</li>
</ol>
<hr>
<h1 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h1><h2 id="分层存储器系统"><a href="#分层存储器系统" class="headerlink" title="分层存储器系统"></a>分层存储器系统</h2><h3 id="内存基础"><a href="#内存基础" class="headerlink" title="内存基础"></a>内存基础</h3><p>帕金森定律：不管存储器有多大，程序都可以把它填满</p>
<p>内存是用于存放数据的硬件，程序执行前需要先放到内存中才能被CPU处理</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-31-43-197_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-31-43-197_com.orion.notein-edit"></p>
<ul>
<li><strong>寄存器</strong>：是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果，对寄存器的访问速度最快</li>
<li><strong>高速缓存</strong>（Cache）：主要用于备份主存中较常用的数据，以减少处理机对内存的访问次数，提高程序执行速度。为了缓和内存与处理机速度之间的矛盾</li>
<li><strong>主存储器</strong>（内存）：用于保存进程运行时的程序和数据</li>
<li><strong>磁盘缓存</strong>：暂时存放频繁使用的一部分磁盘数据和信息，减少访问磁盘的次数</li>
</ul>
<p>寄存器和主存储器被称为<strong>可执行存储器</strong></p>
<p><strong>外存</strong>：外储存器是指除计算机内存及CPU缓存以外的储存器，此类储存器一般断电后仍然能保存数据。外存需要通过I&#x2F;O系统与之交换数据，又称为辅助存储器。常见的外储存器有硬盘、软盘、光盘、U盘等</p>
<hr>
<h3 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h3><p>方法一：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。但是需要存储在连续的地址</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-35-01-609_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-35-01-609_com.orion.notein-edit"></p>
<p>方法二：采用重定位寄存器（基址寄存器）和界址寄存器（限长寄存器）进行越界检查，重定位寄存器中存放的是进程的起始<strong>物理地址</strong>；界址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。可用于非连续存储或虚拟内存</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-36-08-047_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-36-08-047_com.orion.notein-edit"></p>
<hr>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><ol>
<li>编译：由编译程序将用户源代码编译成若干目标模块（高级 -&gt; 机器）</li>
<li>链接：由链接程序将编译后的目标模块和<strong>所需库函数</strong>链接在一起，形成一个完整的装入程序</li>
<li>装入：由装入程序将装入模块装入内存运行</li>
</ol>
<h3 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h3><p><strong>物理地址</strong> &#x2F; 绝对地址：物理内存中实际地址，内存单元看到的地址（即装入内存地址寄存器的地址）</p>
<p><strong>逻辑地址</strong> &#x2F; 相对地址：<strong>相对于程序开始地址</strong>的地址，由CPU生成</p>
<p>地址空间：一个进程可用于寻址内存的一套地址集合，独立于其他进程</p>
<p>绝对装入：直接访问物理内存，导致同时运行两个程序可能导致崩溃，不同时运行也可能崩溃</p>
<h4 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h4><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-41-44-410_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-41-44-410_com.orion.notein-edit"></p>
<p>又称为<strong>可重定位装入</strong>，编译、链接后的装入模块的地址都是从0开始的。指令中使用的地址，数据存放的地址都是相对于起始地址而言的逻辑地址。装入内存后，对地址进行“重定位”</p>
<p>特点：在一个作业装入内存时，必须分配其要求的全部内存空间。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间</p>
<h4 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h4><p>又称为动态运行时装入，编译、链接后的装入模块的地址都是从0开始的，装入内存后，并不会立即进行转换，而是把地址转换推迟到程序真正要<strong>执行时才进行</strong>。因此装入内存的依然是逻辑地址。需要<strong>重定位寄存器</strong>支持。允许程序在内存中发生移动</p>
<blockquote>
<p>模块在内存中的起始地址 + 目标内存单元相对于起始位置的偏移量</p>
</blockquote>
<hr>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接程序的功能是将目标模块以及它们所需的库函数装配成一个完整的装入模块</p>
<p>链接后形成的目标程序中的地址就是逻辑地址</p>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完成的可执行文件，之后不再拆开</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-45-00-617_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-45-00-617_com.orion.notein-edit"></p>
<h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p>将各目标模块装入内存时，边装入边链接的链接方式。其优点是便于修改和更新，以及实现对目标模块的共享</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-45-52-878_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-45-52-878_com.orion.notein-edit"></p>
<h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>在程序执行中需要该目标模块时，才对它进行链接。优点是加快程序的装入过程，且节省内存空间</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-46-25-544_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-46-25-544_com.orion.notein-edit"></p>
<hr>
<h2 id="连续分配存储方式"><a href="#连续分配存储方式" class="headerlink" title="连续分配存储方式"></a>连续分配存储方式</h2><p>程序装入内存前，必须为它分配一定大小的存储空间</p>
<h3 id="碎片问题"><a href="#碎片问题" class="headerlink" title="碎片问题"></a>碎片问题</h3><p>内存分配会导致碎片问题：</p>
<p><strong>内部碎片</strong>：分配给某个进程的内存区域中，有空闲</p>
<p><strong>外部碎片</strong>：内存中的某些空闲分区由于太小而无法分配。可采用紧凑技术来解决</p>
<hr>
<h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-50-15-757_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-50-15-757_com.orion.notein-edit"></p>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>将整个用户空间划分为若干固定大小的区域</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-08-51-49-510_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-08-51-49-510_com.orion.notein-edit"></p>
<p>优点：简单，无外部碎片</p>
<p>缺点：内存利用率低。程序太大而分区太小，使用覆盖技术设计程序；程序太小也要占用整个分区，从而导致内部碎片</p>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ul>
<li>对应的数据结构：空闲分区表和空闲分区链</li>
</ul>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-01-26-907_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-01-26-907_com.orion.notein-edit"></p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-02-10-097_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-02-10-097_com.orion.notein-edit"></p>
<p><strong>动态分区分配没有内部碎片</strong>，但有外部碎片</p>
<h4 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h4><p>基于顺序搜索：首次适应、下次适配算法、最佳适配算法、最差适配算法</p>
<ul>
<li><p><strong>首次适应算法</strong>（FF）：每次都<strong>从低地址开始查找</strong>，找到第一个能满足大小需求的空闲分区</p>
</li>
<li><p><strong>下次适配算法</strong>（NF）：每次找到合适的空闲区时都记录当时的位置，以便在<strong>下次寻找空闲区时从上次结束的地方开始搜索</strong></p>
</li>
<li><p><strong>最佳适配算法</strong>（BF）：搜索整个链表，找出能够容纳进程的最小空闲区，即<strong>试图找出最接近实际需要的空闲区</strong></p>
</li>
<li><p><strong>最差适配算法</strong>（WF）：该算法总是<strong>分配最大的可用空闲区</strong>，使新的空闲区比较大从而可以继续使用</p>
</li>
</ul>
<p>以上四种方法，随着时间的推移，内存中会形成越来越多的外部碎片，内存的利用率随之下降</p>
<p>基于索引搜索：快速适应、伙伴系统、哈希算法</p>
<h4 id="分配回收"><a href="#分配回收" class="headerlink" title="分配回收"></a>分配回收</h4><p>上相邻：回收分区的上邻分区是空闲的，需要将两个相邻的空闲区合并成一个更大的空闲区，然后修改空闲区表</p>
<p>下相邻：回收分区的下邻分区是空闲的，需要将两个相邻的空闲区合并成一个更大的空闲区，然后修改空闲区表</p>
<p>上下相邻：回收分区的上、下邻分区都是空闲的（空闲区个数为2），需要将三个空闲区合并成一个更大的空闲区（空闲区个数为1 ），然后修改空闲区表</p>
<p>上下都不相邻：回收分区的上、下邻分区都不是空闲的，则直接将空闲区记录在空闲区表中</p>
<hr>
<h2 id="非连续分配方式"><a href="#非连续分配方式" class="headerlink" title="非连续分配方式"></a>非连续分配方式</h2><p>实际应用中，所有进程所需的内存容量通常要远远超出存储器能够支持的范围，现通用的方法有：交换技术和虚拟内存技术</p>
<p><strong>虚拟存储</strong>只能基于非连续分配技术</p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><blockquote>
<p>将程序分为多个段（模块）。常用的段常驻内存，不常用的段在需要时调入内存</p>
</blockquote>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-17-54-523_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-17-54-523_com.orion.notein-edit">                       </p>
<h4 id="交换技术-1"><a href="#交换技术-1" class="headerlink" title="交换技术"></a>交换技术</h4><blockquote>
<p>内存空间紧张时，系统将内存中暂时不能运行的或不用打进程（或数据）暂时移到外存（挂起），把外存中已具备运行条件的进程交换进内存</p>
</blockquote>
<hr>
<h3 id="地址空间结构"><a href="#地址空间结构" class="headerlink" title="地址空间结构"></a>地址空间结构</h3><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-33-00-233_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-33-00-233_com.orion.notein-edit"></p>
<p>例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 全局初始化区</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>    <span class="token comment">// 全局未初始化区</span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> b<span class="token punctuation">;</span>    <span class="token comment">// 栈</span>
    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 栈</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>    <span class="token comment">// 栈</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span>    <span class="token comment">// 123456\0在常量区，p3在栈上</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 全局（静态）初始化区</span>
    p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 分配得来的区域在堆区</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<hr>
<h3 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h3><p>如果允许将一个进程分散地装入到许多不相邻的分区中，便可更充分地利用内容，从而产生<strong>非连续分配方式</strong></p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>用户进程的地址空间被划分为大小相等的分区（或块），称为<strong>页</strong>或<strong>页面</strong>（page），从0开始编号</p>
<p>内存空间按同样大小划分为大小相等的块，称为<strong>页框</strong>（frame），或称物理页面、页帧、内存块，物理块等，也从0开始编号</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-48-50-790_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-48-50-790_com.orion.notein-edit"></p>
<hr>
<h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><p>系统以<strong>页框为单位</strong>为各个进程分配内存。典型的页面大小：4K或4M（大小必须是2的整数倍）</p>
<p>页面与页框是一一对应关系。逻辑上相邻的页，物理上不一定相邻。划分是系统自动完成的，对用户是透明的</p>
<p>分页技术会产生较少的内部碎片，<strong>没有任何外部碎片</strong></p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-29-09-58-47-088_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-29-09-58-47-088_com.orion.notein-edit"></p>
<p>计算：十进制数表示逻辑地址时，</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240605220741911.png" alt="image-20240605220741911"></p>
<hr>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为<strong>每个进程建立一张页表</strong></p>
<p>页表项（PTE）：记录了逻辑页号与页框号的对应关系，存放在内存（或虚存），页表起始地址保存在<strong>页表寄存器</strong>中，其结构包括：</p>
<ul>
<li>页框号：物理页面号</li>
<li>有效位（在&#x2F;不在位）：1表示该页在内存，0表示不在内存</li>
<li>访问位：此页是否被访问过</li>
<li>修改位：此页在内存中是否被修改过</li>
<li>保护位：只读&#x2F;可读写</li>
<li>用户&#x2F;内核位，高速缓存禁止位等</li>
</ul>
<hr>
<h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>为了提高<strong>地址变换</strong>速度，可在地址变换机构中增设一个具有并行查询能力的高速缓冲寄存器</p>
<p>将<strong>逻辑（虚拟）地址直接映射到物理地址</strong>，而不必访问页表。这种设备称为<strong>地址变换高速缓存（TLB）</strong>，即<strong>快表</strong></p>
<p>此时的地址变换过程：</p>
<ol>
<li><p>CPU给出有效地址后，由地址变换机构自动地将页号送入快表</p>
</li>
<li><p>并将此页号与快表中的所有页号进行比较</p>
<ul>
<li><p>若匹配到（TLB命中），可直接从快表中读出该页所对应的物理块号b，并将其送到物理地址寄存器中</p>
</li>
<li><p>若TLB未命中，则还需再访问内存中的页表，直至找到后，把从页表项读出的物理块号送到地址寄存器；同时，再将此页表项存入快表的一个寄存器单元中，即重新修改快表</p>
<ul>
<li>若快表已满，则OS必须找到一个老的且已被认为是不再需要的页表项，并将它换出</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>让线性页表的一部分消失（释放这些帧用于其他用途），并用页目录来记录页表的哪些页被分配</p>
<hr>
<h4 id="基址变换机构"><a href="#基址变换机构" class="headerlink" title="基址变换机构"></a>基址变换机构</h4><blockquote>
<p>负责将页表中的逻辑地址转换为物理地址</p>
</blockquote>
<p>通常会在系统中设置一个<strong>页表寄存器</strong>（PTR），存放页表在内存中的<strong>起始地址F</strong>和<strong>页表长度M</strong>。进程未执行时，页表的始址和页表长度放在<strong>进程控制块PCB</strong>中，当进程被调度时，系统内核会把它们放到PTR中</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Screenshot_2024-05-30-17-19-27-735_com.orion.notein-edit.jpg" alt="Screenshot_2024-05-30-17-19-27-735_com.orion.notein-edit"></p>
<hr>
<h4 id="地址转换的计算"><a href="#地址转换的计算" class="headerlink" title="地址转换的计算"></a>地址转换的计算</h4><ol>
<li>算出逻辑地址对应的页号 &#x3D; 逻辑地址 &#x2F; 页面长度（下取整）</li>
<li>获取该页号对应页面在内存中的起始地址</li>
<li>算出逻辑地址在页面内的逻辑量 &#x3D; 逻辑地址 % 页面长度</li>
<li>物理地址 &#x3D; 页面起始地址 + 页内偏移量</li>
</ol>
<hr>
<h3 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h3><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>段表记录了段与内存位置的对应关系。</p>
<p>段表保存在内存中</p>
<p>段表的基址及长度由段表寄存器给出</p>
<p>地址映射表：每个进程一张段表，每个段一张页表</p>
<hr>
<h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><blockquote>
<p>程序执行过程中，数据和指令往往倾向于在短时间内多次访问一部分的地址空间，而不是随机地访问整个地址空间</p>
</blockquote>
<p>形式：</p>
<ol>
<li><strong>时间局部性</strong>（Temporal Locality）：当程序访问了某个存储单元（如内存中的某个数据）后，很可能<strong>在不久的将来再次访问相同的存储单元</strong>。这表明程序具有重复访问相同数据的趋势</li>
<li><strong>空间局部性</strong>（Spatial Locality）：当程序访问了某个存储单元后，<strong>很可能在不久的将来访问其附近的存储单元</strong>。这表明程序倾向于顺序地访问内存，使得紧邻的数据也被频繁地访问</li>
</ol>
<p>局部性原理使得虚拟存储技术的实现成为可能</p>
<p>虚拟内存：是一种计算机操作系统的技术，它允许程序<strong>使用比实际物理内存更大的虚拟地址空间</strong></p>
<hr>
<h2 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h2><p>为了解决<strong>系统内存容量不足</strong></p>
<p>在请求分页系统中，只要求将当前最需要的一部分页面装入内存，就可以启动作业进行运行</p>
<p>当需要访问的页面不在内存中时，可通过<strong>调页功能</strong>将其调入内存，通过<strong>置换功能</strong>将暂时不用的页面调到外存</p>
<h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>主要的数据结构，将用户地址空间中的逻辑地址映射为内存空间中的物理地址</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240630013033513.png" alt="image-20240630013033513"></p>
<ul>
<li><strong>状态位</strong>：用于指示该页是否已调入内存，供程序访问时参考</li>
<li>**访问字段(A)**：记录本页在一段时间内被访问的次数，或者记录本页最近已有多久时间未被访问，供置换算法在选择换出页面时参考</li>
<li>**修改位(M)**：表示该页在调入内存之后有没有被修改。供置换页面时参考。未修改则无需写入外存。</li>
<li><strong>外存地址</strong>：<strong>用于指出该页在外存上的地址，通常是物理块号地址</strong>，供调入该页时参考。</li>
</ul>
<hr>
<h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>当所要访问的页面不在内存时，便产生一缺页中断，请求 OS 将缺的页调入内存</p>
<p>注：缺页中断属于<strong>内中断</strong>，一条指令在执行期间，可能会产生<strong>多次</strong>缺页中断</p>
<hr>
<h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><p>逻辑地址到物理地址的变换</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240630013524148.png" alt="image-20240630013524148"></p>
<ul>
<li>在进行地址变换时，首先检索快表，试图从中找出所要访问的页<ol>
<li>若找到，便修改页表项中的访问位，供置换算法选换出页面时参考</li>
<li>对于写指令，还须将修改位改成“1”，表示该页在调入内存后已被修改</li>
<li>然后利用页表项中给出的物理块号和页内地址形成物理地址</li>
</ol>
</li>
<li>如果在快表中未找到该页的页表项，则应到内存中去查找页表，再从找到的页表项中的状态位 P 来了解该页是否已调入内存<ol>
<li>若该页已调入内存，这时应将该页的页表项写入快表</li>
<li>当快表已满时，则应先调出按某种算法所确定的页的页表项，然后再写入该页的页表项</li>
<li>若该页尚未调入内存，这时应产生缺页中断，请求 OS 从外存把该页调入内存</li>
</ol>
</li>
</ul>
<hr>
<h2 id="虚拟内存管理策略"><a href="#虚拟内存管理策略" class="headerlink" title="虚拟内存管理策略"></a>虚拟内存管理策略</h2><h3 id="读取策略"><a href="#读取策略" class="headerlink" title="读取策略"></a>读取策略</h3><p>确定一个页何时取入内存，常用的两种方法是<strong>请求分页和预先分页</strong></p>
<ul>
<li><strong>请求分页</strong>：只有当访问到某页中的一个单元时才将该页取入内存</li>
<li><strong>预先分页</strong>：读取的页并不是缺页中断请求的页</li>
</ul>
<hr>
<h3 id="放置策略"><a href="#放置策略" class="headerlink" title="放置策略"></a>放置策略</h3><p>决定一个进程块驻留在实存中的什么地方</p>
<hr>
<h3 id="置换策略"><a href="#置换策略" class="headerlink" title="置换策略"></a>置换策略</h3><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>抖动：一个进程在运行中把大部分时间都花费在了页面置换工作上</p>
<ul>
<li><strong>先进先出（FIFO）</strong>：总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰</li>
<li><strong>最佳页面置换算法（OPT）</strong>：将<strong>未来最长时间不会被访问</strong>的页面淘汰</li>
<li><strong>最近最久未使用页面置换算法（LRU）</strong>：将<strong>最近最久未使用的页面</strong>进行淘汰</li>
</ul>
<p>做题：参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kJ411E7AQ">https://www.bilibili.com/video/BV1kJ411E7AQ</a></p>
<p>画表格进行判断</p>
<table>
<thead>
<tr>
<th>页面走向</th>
<th>1</th>
<th>2</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>物理页0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理页1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理页2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺页</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h5><p>先进先出，谁长换谁</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240629021639207.png" alt="image-20240629021639207"></p>
<p>前4个走向都是直接置换进去，所以均存在缺页</p>
<p>第5个开始，因为1存在的时间最久（即连续占的格子最多），于是5和1置换，以此类推</p>
<p>缺页率：缺页数 &#x2F; 页面走向的总数</p>
<h5 id="OPT"><a href="#OPT" class="headerlink" title="OPT"></a>OPT</h5><p>往右看，谁最远首次出现换谁</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240629022239350.png" alt="image-20240629022239350"></p>
<p>注：遇到出现两个以上可换的情况时，继续遵循FIFO</p>
<h5 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h5><p>往左看，谁最远首次出现换谁</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240629022500398.png" alt="image-20240629022500398"></p>
<p>缺点：可能出现Belady异常现象</p>
<h5 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h5><p>可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。我们给每一个页面设置一个标记位u，<strong>u&#x3D;1表示最近有使用</strong>；<strong>u&#x3D;0则表示该页面最近没有被使用，应该被逐出</strong></p>
<p>按照1-2-3-4的顺序访问页面，则缓冲池会以这样的一种顺序被填满：</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240630165231766.png" alt="image-20240630165231766"></p>
<p>注意中间的指针，就像是时钟的指针一样在移动，这样的访问结束后，缓冲池里现在已经被填满了</p>
<p>此时如果要按照1-5的顺序访问，那么在访问1的时候是可以直接命中缓存返回的</p>
<p>但是访问5的时候，因为缓冲池已经满了，所以要进行一次逐出操作，其操作示意图如下：</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240630165311193.png" alt="image-20240630165311193"></p>
<p>最初要经过一轮遍历，每次遍历到一个节点发现u&#x3D;1的，将该标记位置为0，然后遍历下一个页面，一轮遍历完后，发现没有可以被逐出的页面，则进行下一轮遍历，这次遍历之后发现原先1号页面的标记位u&#x3D;0，则将该页面逐出，置换为页面5，并将指针指向下一个页面</p>
<p>假设我们接下来会访问2号页面，那么可以直接命中指针指向的页面，并将这个页面的标记为u置为1</p>
<p>但是考虑一个问题：数据库里逐出的页面是要写回磁盘的，这是一个很昂贵的操作，因此我们应该优先考虑逐出那些没有被修改的页面，这样可以降低IO</p>
<p>于是对Clock算法做一个改进：增加一个标记为<code>m</code>，修改过标记为1，没有修改过则标记为0</p>
<ul>
<li><code>(u=0, m=0)</code> 没有使用也没有修改，被逐出的优先级最高；</li>
<li><code>(u=1, m=0)</code> 使用过，但是没有修改过，优先级第二；</li>
<li><code>(u=0, m=1)</code> 没有使用过，但是修改过，优先级第三；</li>
<li><code>(u=1, m=1)</code> 使用过也修改过，优先级第四。</li>
</ul>
<hr>
<h4 id="页缓冲"><a href="#页缓冲" class="headerlink" title="页缓冲"></a>页缓冲</h4><p>一种可以提高分页的性能并且允许使用较简单的页面置换策略的方法</p>
<h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><p>在某段时间间隔里，进程实际访问页面的集合</p>
<hr>
<h3 id="驻留集管理"><a href="#驻留集管理" class="headerlink" title="驻留集管理"></a>驻留集管理</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>是进程当前分配到物理页框中的所有页构成的集合，即给进程分配的物理块的集合，受操作系统分页分配策略和内存可用状态影响</p>
<p>驻留集大小问题：即操作系统决定分配多大的内存空间给进程的问题</p>
<h4 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h4><ul>
<li><strong>固定分配策略</strong>：为一个进程在内存中分配固定数量的页框，以供执行时使用。一旦发生缺页中断，进程的一页必须被置换</li>
<li><strong>可变分配策略</strong>：允许分配给一个进程的页框在该进程的生命周期中不断地发生变化。若该进程的缺页率高，则多分配页框；若特别低，则可适当减少页框</li>
</ul>
<h4 id="置换范围"><a href="#置换范围" class="headerlink" title="置换范围"></a>置换范围</h4><ul>
<li><strong>局部置换策略</strong>：发生缺页时，仅选进程自己的物理块进行置换</li>
<li><strong>全局置换策略</strong>：可以将系统保留的空闲物理块分配给缺页进程，也可将别的进程持有的物理块置换到外存，再分配给缺页进程</li>
</ul>
<p>注：全局意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配，即<strong>固定分配,全局置换不可能同时存在</strong></p>
<hr>
<h3 id="清除策略"><a href="#清除策略" class="headerlink" title="清除策略"></a>清除策略</h3><p>用于确定何时将已修改的一页写回辅存</p>
<ul>
<li>请求式：只有当一页被选择用于置换时才被写回</li>
<li>预约式：将这些已修改的多页在需要使用它们所占据的页框之前成批写回</li>
</ul>
<hr>
<h2 id="请求分段存储管理"><a href="#请求分段存储管理" class="headerlink" title="请求分段存储管理"></a>请求分段存储管理</h2><h3 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h3><h4 id="请求段表机制"><a href="#请求段表机制" class="headerlink" title="请求段表机制"></a>请求段表机制</h4><p>请求分段的段表项：</p>
<p><code>| 段名 | 段长 | 段基址 | 存取方式 | 访问字典 A | 修改位 M | 存在位 P | 增补位 | 外存始址 |</code></p>
<ul>
<li>存取方式：标识只执行、只读、读写</li>
<li>访问字段 A：记录该段被访问的频繁程度</li>
<li>修改位M：表示该段在进入内存后，是否被修改过</li>
<li>存在位P：表示该段是否在内存中</li>
<li>增补位：用于本段在运行过程中是否做过动态增长</li>
</ul>
<h4 id="缺段中断机构"><a href="#缺段中断机构" class="headerlink" title="缺段中断机构"></a>缺段中断机构</h4><h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><hr>
<h3 id="共享与保护"><a href="#共享与保护" class="headerlink" title="共享与保护"></a>共享与保护</h3><hr>
<h1 id="输入输出系统管理"><a href="#输入输出系统管理" class="headerlink" title="输入输出系统管理"></a>输入输出系统管理</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><h3 id="设备无关性"><a href="#设备无关性" class="headerlink" title="设备无关性"></a>设备无关性</h3><p>又称设备独立性：操作系统<strong>把所有外部设备统一当作成文件</strong>来看待，只要安装它们的驱动程序，任何用户都可以象使用文件一样，操纵、使用这些设备，而不必知道它们的具体存在形式</p>
<p>实现：引入<strong>逻辑设备</strong>和<strong>物理设备</strong>两个概念，在<strong>应用程序</strong>中，使用逻辑设备名来请求使用某类设备；而在<strong>系统实际执行</strong>时，必须将逻辑设备名映射成物理设备名使用</p>
<hr>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><h4 id="从传输速率看"><a href="#从传输速率看" class="headerlink" title="从传输速率看"></a>从传输速率看</h4><ul>
<li>低速设备：如<strong>鼠标、键盘</strong>等，速率为几个~几百字节每秒</li>
<li>中速设备：如<strong>激光打印机</strong>等，速率为数千~上万字节每秒</li>
<li>高速设备：如<strong>磁盘</strong>等，速率为数千~千兆字节每秒</li>
</ul>
<h4 id="从信息单位看"><a href="#从信息单位看" class="headerlink" title="从信息单位看"></a>从信息单位看</h4><ul>
<li><strong>块设备</strong>：把信息存储在固定大小的块中，每个块都有自己的地址（可寻址）。通常块的大小在512B到64KB之间。所有传输以一个或多个完整的连续的块为单位。其特征是每个块都能独立于其他块而读写。如<strong>硬盘、蓝光光盘和U盘</strong>等</li>
<li><strong>字符设备</strong>：以字符为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。如<strong>打印机、网络接口、鼠标</strong>等</li>
</ul>
<p>注意：一些设备既不是块设备，也不是字符设备，比如cpu时钟，即不可寻址，也不产生或接收字符流。它仅按照预先规定好的时间间隔产生中断；内存映射的显示器也如此</p>
<h4 id="从资源分配看"><a href="#从资源分配看" class="headerlink" title="从资源分配看"></a>从资源分配看</h4><ul>
<li><strong>独占设备</strong>：在一段时间内只能有一个进程使用的设备，一般为低速设备，如<strong>打印机、磁带</strong>等</li>
<li><strong>共享设备</strong>：在一段时间内<strong>允许有多个进程共同使用</strong>的设备，多个进程以交叉的方式使用设备，其资源利用率高，如<strong>硬盘</strong>等。必须是<strong>可寻址的和可随机访问</strong>的设备</li>
<li><strong>虚拟设备</strong>：在一类设备上模拟另一类设备，常用共享设备模拟独占设备，被模拟的设备称为虚设备，如<strong>用硬盘模拟IO设备的SPOOLING技术</strong></li>
</ul>
<hr>
<h2 id="硬件原理"><a href="#硬件原理" class="headerlink" title="硬件原理"></a>硬件原理</h2><h3 id="IO控制器"><a href="#IO控制器" class="headerlink" title="IO控制器"></a>IO控制器</h3><h4 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h4><ul>
<li><strong>接收和识别CPU发出的命令</strong>，如CPU发来的 read&#x2F;write 命令，控制器中控制寄存器用来存放命令和参数</li>
<li><strong>向CPU报告设备的状态</strong>，控制器中有<strong>状态寄存器</strong>，用于记录IO设备的当前状态，如空闲或忙碌</li>
<li><strong>数据交换</strong>，控制器有<strong>数据寄存器</strong>。在输出时，用于暂存CPU发来的数据，之后再由控制器传送给设备；输入时，用于暂存设备发来的数据，之后CPU从中取走数据</li>
<li><strong>地址识别</strong>，为了区分控制器中的各个寄存器，也需要给它们设置一个特定的地址。控制器通过该地址来判断CPU要读&#x2F;写的是哪个寄存器</li>
</ul>
<hr>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240630174006027.png" alt="image-20240630174006027"></p>
<ul>
<li><p>一个I&#x2F;O控制器可能会对应多个设备</p>
</li>
<li><p>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制&#x2F;状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I&#x2F;O；另一些计算机则采用I&#x2F;O专用地址，即寄存器独立编址</p>
</li>
</ul>
<hr>
<h3 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h3><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240630174314794.png" alt="image-20240630174314794"></p>
<h4 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h4><ol>
<li>CPU发出读写命令，将等待IO进程阻塞。切换其他进程执行。</li>
<li>当IO完成后，控制器向CPU发出一个中断信号，CPU检测到中断信号后，会切换进程，处理中断。</li>
<li>CPU将一个字的数据传送到CPU寄存器，再写入主存。</li>
<li>CPU恢复等待IO的进程（或其他进程）的运行环境，然后继续执行。</li>
</ol>
<p>例：键盘输入信息</p>
<h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><blockquote>
<p>Direct Memeoy Access，直接存储器存取</p>
</blockquote>
<p>主要用于块设备的IO控制</p>
<p>数据的传送单位是块，不再是一个字、一个字的传送</p>
<p>数据的流向是设备-&gt;内存，或者内存-&gt;设备，不再需要CPU作为中间媒介，在<strong>IO设备和主存</strong>之间建立一条直接数据通路</p>
<p>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p>
<h4 id="IO通道控制方式"><a href="#IO通道控制方式" class="headerlink" title="IO通道控制方式"></a>IO通道控制方式</h4><p>通道又称为IO处理机,它主要用于实现<strong>内存与外设</strong>之间的信息传输</p>
<p>通道控制设备控制器，设备控制器控制设备工作</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240630174828102.png" alt="image-20240630174828102"></p>
<ol>
<li>CPU向通道发出IO指令，指明通道程序在内存中的位置，并指明要操作哪个IO设备，之后CPU就切换到其他进程执行了。</li>
<li>通道执行内存中的通道程序。比如指明要读入、写出多少数据，读写数据应放在内存的什么位置等信息。</li>
<li><strong>通道执行完规定的任务后，向CPU发出中断信号</strong>，之后CPU对中断进行处理。</li>
</ol>
<hr>
<h2 id="软件原理"><a href="#软件原理" class="headerlink" title="软件原理"></a>软件原理</h2><h3 id="层次划分"><a href="#层次划分" class="headerlink" title="层次划分"></a>层次划分</h3><p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240630175057751.png" alt="image-20240630175057751"></p>
<ul>
<li>用户层软件：通过系统调用请求设备独立性软件层的服务</li>
<li>设备独立性软件层（设备无关软件）：根据LUT调用设备对应的驱动程序</li>
<li>驱动程序：向IO控制器发出具体命令</li>
<li>中断处理</li>
<li>等待IO完成的进程应该被阻塞，因此需要进程切换，而进程切换必然需要中断处理</li>
</ul>
<hr>
<h3 id="设计关键"><a href="#设计关键" class="headerlink" title="设计关键"></a>设计关键</h3><ul>
<li><p><strong>设备独立性</strong>：程序可以访问任意IO设备而无需事先指定设备，如读取一个文件作为输入的程序应该能够从硬盘、光盘或U盘上读取文件，无需为每一种不同设备修改程序</p>
</li>
<li><p><strong>统一命名</strong>：一个文件或一个设备的名字应该是一个简单的字符串或一个整数，不依赖于设备；而所有文件和设备都采用相同的方式进行路径寻址</p>
</li>
<li><p><strong>错误处理</strong>：错误应尽可能地在接近硬件的层面得到处理。比如控制器发现一个读错误时，它能够自己处理，如果处理不了才交给设备驱动程序，高层软件可能不知道该错误的存在</p>
</li>
<li><p><strong>同步和异步</strong>：大多数物理IO是异步的，cpu启动传输后便转去做其他工作，直到中断发生；如果IO操作是同步的，则比较容易实现，比如用户程序在系统调用read之后，直接挂起，直到缓冲区中的数据准备好</p>
</li>
<li><p><strong>缓冲</strong>：数据离开一个设备之后通常并不能直接存放到其最终的目的地，此外，有些设备具有严格的实时约束（如数字音频设备），所以数据必须预先放置到输出缓冲区中</p>
</li>
<li><p><strong>共享和独占</strong>：磁盘可以由多个用户同时使用，但磁带机就不行。独占设备的引入也带来许多问题，如死锁。操作系统必须能够处理共享设备和独占设备以避免问题发生</p>
</li>
</ul>
<hr>
<h3 id="核心子系统"><a href="#核心子系统" class="headerlink" title="核心子系统"></a>核心子系统</h3><h4 id="假脱机技术（SPOOLing）"><a href="#假脱机技术（SPOOLing）" class="headerlink" title="假脱机技术（SPOOLing）"></a>假脱机技术（SPOOLing）</h4><blockquote>
<p>是一种用软件的方式模拟脱机工作方式的技术</p>
</blockquote>
<p>脱机（输入&#x2F;输出）：脱离主机的控制而进行的输入&#x2F;输出操作的一种方法</p>
<p>批处理系统中引入脱机技术是为了缓解CPU与慢速IO设备的速度矛盾问题，以空间换取时间</p>
<p>组成：</p>
<p>预输入程序、井管理程序和缓输出程序</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240630220445685.png" alt="image-20240630220445685"></p>
<ul>
<li><p><strong>输入进程</strong>：模拟脱机输入时的外围控制机</p>
</li>
<li><p><strong>输出进程</strong>：模拟脱机输出时的外围控制机</p>
</li>
<li><p><strong>输入缓冲区</strong>：用于暂存从输入设备输入的数据，之后再转存到输入井中</p>
</li>
<li><p><strong>输出缓冲区</strong>：用于暂存从输出井送来的数据，之后再传送到输出设备上</p>
</li>
<li><p><strong>输入井</strong>：模拟脱机输入时的磁盘，用于收容I&#x2F;O设备输入的数据</p>
</li>
<li><p><strong>输出井</strong>：模拟脱机输出时的磁盘，用于收容用户程序的输出数据</p>
<p>输入&#x2F;输出井中的数据一般以文件的形式组织管理，我们把这些文件成为井文件。一个文件仅存放某一个进程的输入或者输出数据，所有进程的输入或者输出文件链接成为一个输入（或输出）队列</p>
</li>
<li><p><strong>井管理程序</strong>：用于控制作业与磁盘之间信息的交换。当作业执行过程中向某台设备发出启动输入或输出操作请求时，由操作系统调用井管理程序，由其控制从输入井读取信息或将信息输出至输出井</p>
</li>
</ul>
<hr>
<h4 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h4><blockquote>
<p>缓冲区是一个存储区域，可由专门的硬件寄存器组成，也可用内存作为缓冲区</p>
</blockquote>
<p>在系统内存中设置磁盘缓冲区的主要目的：减少磁盘IO次数</p>
<h5 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h5><p>为了加快输入和输出速度，提高设备利用率，引入了双缓冲区机制（<strong>缓冲区对换</strong>）。若采用双缓冲的策略，系统会在主存中为其分配两个缓冲区（一般一个缓冲区大小就是一块）</p>
<p>不存在等待磁盘块从缓冲区读入用户区的问题	</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240701003108731.png" alt="image-20240701003108731"></p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240701003250438.png" alt="image-20240701003250438"></p>
<p>采用双缓冲策略，处理一个数据块的平均耗时为<code>Max(T, C+M)</code></p>
<hr>
<h2 id="输入输出设备（磁盘）"><a href="#输入输出设备（磁盘）" class="headerlink" title="输入输出设备（磁盘）"></a>输入输出设备（磁盘）</h2><p>处理流程：<code>用户程序-&gt;系统调用处理程序-&gt;设备驱动程序-&gt;中断处理程序</code></p>
<p>设备驱动程序：计算数据所在磁盘的柱面号、磁头号、扇区号</p>
<h3 id="性能参数"><a href="#性能参数" class="headerlink" title="性能参数"></a>性能参数</h3><p>寻道时间、旋转延迟、传输时间、时序比较</p>
<hr>
<h3 id="调度算法-1"><a href="#调度算法-1" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h4><p>按请求的接收顺序完成请求</p>
<h4 id="最短寻道优先SSF"><a href="#最短寻道优先SSF" class="headerlink" title="最短寻道优先SSF"></a>最短寻道优先SSF</h4><p>下一次总是处理与磁头距离最近的请求以使寻道时间最小</p>
<h4 id="电梯算法SCAN"><a href="#电梯算法SCAN" class="headerlink" title="电梯算法SCAN"></a>电梯算法SCAN</h4><p>保持按一个方向移动，直到在那个方向上没有请求为止，后改变方向</p>
<h4 id="循环扫描算法CSCAN"><a href="#循环扫描算法CSCAN" class="headerlink" title="循环扫描算法CSCAN"></a>循环扫描算法CSCAN</h4><p>CSCAN把扫描限定在一个方向上，当访问到某个方向的最后一个磁道后，磁头臂返回到相反方向末端的磁道，并再次开始扫描</p>
<hr>
<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="文件和文件系统"><a href="#文件和文件系统" class="headerlink" title="文件和文件系统"></a>文件和文件系统</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>文件系统是OS的一部分，提供了一种管理机制，以便OS对自身及所有用户的数据与程序进行在线存储和访问</p>
<p>文件系统由两部分组成：<strong>文件集合和目录</strong></p>
<p>文件是指具有文件名的若干相关元素的集合</p>
<p>数据的组成可以分为三级：</p>
<ol>
<li><p><strong>数据项</strong>：数据名，数据类型</p>
</li>
<li><p><strong>记录</strong>：一组相关数据项的集合，用于描述一个对象在某方面的属性</p>
</li>
<li><p><strong>文件</strong>：分为<strong>有结构文件</strong>（由若干相关记录组成）和<strong>无结构文件</strong>（一个字节流），主要属性有文件类型、文件长度、文件的物理位置、文件的建立时间</p>
</li>
</ol>
<hr>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>按文件是否有结构来分：</p>
<ul>
<li>有结构文件</li>
<li>无结构文件</li>
</ul>
<p>按文件的组织方式来分：</p>
<ul>
<li>顺序文件：由一系列记录按某种顺序排列所形成的文件，其中的记录可以是定长记录或可变长记录</li>
<li>索引文件：为可变长记录文件建立一张索引表，为每个记录设置一个索引表项</li>
<li>索引顺序文件</li>
</ul>
<p>直接文件：可根据给定关键字直接获取指定记录的物理地址。即关键字决定了记录的物理地址。</p>
<p>哈希文件：哈希文件也称为散列文件，是利用哈希存储方式组织的文件，亦称为直接存取文件。它类似于哈希表，即根据文件中关键字的特点，设计一个哈希函数和处理冲突的方法，将记录哈希到存储设备上。</p>
<h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><ul>
<li>连续组织方式</li>
<li>链接组织方式</li>
<li>索引组织方式</li>
</ul>
<hr>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><ul>
<li><strong>目录</strong>：是管理文件系统结构的系统文件</li>
<li><strong>普通文件</strong>：是包含有用户信息的文件，可分为文本文件和二进制文件。前者是没有经过处理的数据（ASCII）；二进制文件则是经过编码的文件，普通的编辑器打不开</li>
<li><strong>特殊文件</strong>：如UNIX中的字符特殊文件和块特殊文件。前者与输入输出有关；后者与磁盘设备有关</li>
</ul>
<hr>
<h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><ul>
<li><strong>顺序访问</strong>：就是从开头开始访问，按先来后到的顺序读取数据。不能在中间随便跳转，但可以进行快进或快退（早期使用）</li>
<li><strong>随机访问</strong>：可按照任意顺序读取数据记录。先seek()，到达指定位置后再开始读写，后又可以再选择新的位置。现代操作系统都提供随机访问</li>
</ul>
<hr>
<h2 id="目录系统"><a href="#目录系统" class="headerlink" title="目录系统"></a>目录系统</h2><h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><blockquote>
<p><strong>文件控制块FCB</strong>是实现文件目录的关键数据结构，实现了文件名和文件之间的映射</p>
</blockquote>
<p>目录文件中的一条记录就是一个文件控制块（FCB）</p>
<p>最重要的是<strong>文件名、文件存放的物理地址</strong>。它们能使用户可以实现“按名存取”</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240701004813588.png" alt="image-20240701004813588"></p>
<p>FCB的有序集合称为<strong>文件目录</strong>，一个FCB就是一个文件目录项。为了创建一个新文件，系统将分配一个FCB并存放在文件目录中，成为目录项</p>
<p>在一个文件被用户进程首次打开的过程中,系统需要做的是<strong>将文件控制块读到内存中</strong></p>
<hr>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="单级目录"><a href="#单级目录" class="headerlink" title="单级目录"></a>单级目录</h4><p>早期操作系统并不支持多级目录，整个系统只建立一张目录表，每个文件占一个目录项</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240701004935561.png" alt="image-20240701004935561"></p>
<p>单级目录实现了“按名存取” ，但不允许文件重名。在创建一个文件时，需要先检查目录表中有没有重名文件，确定不存在后才允许建立文件，并将新文件对应的目录项插入目录表中</p>
<hr>
<h4 id="两级目录"><a href="#两级目录" class="headerlink" title="两级目录"></a>两级目录</h4><p>将文件目录分成<strong>主文件目录</strong>（Master FileDirectory, MFD）和<strong>用户文件目录</strong>（User FileDirectory, UFD）两级</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240701005300637.png" alt="image-20240701005300637"></p>
<hr>
<h4 id="多级目录（树形目录）"><a href="#多级目录（树形目录）" class="headerlink" title="多级目录（树形目录）"></a>多级目录（树形目录）</h4><p>用户要访问某个文件时要用<strong>文件路径名</strong>标识文件，文件路径名是个字符串。各级目录之间用 &quot;&#x2F;&quot; 隔开。可以很方便地对文件进行分类，能有效地进行文件的管理和保护</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240701005452370.png" alt="image-20240701005452370"></p>
<hr>
<h4 id="有向无环图目录"><a href="#有向无环图目录" class="headerlink" title="有向无环图目录"></a>有向无环图目录</h4><hr>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>绝对路径</p>
<p>相对路径</p>
<hr>
<h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p>链接的建立使用操作系统的<code>link()</code>系统调用，该调用给出一个目录名和一个文件名，在操作后，从该目录到该文件将存在一个直系下属关系，我们从该目录可以直接访问该文件</p>
<hr>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><hr>
<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统的布局"><a href="#文件系统的布局" class="headerlink" title="文件系统的布局"></a>文件系统的布局</h3><blockquote>
<p>文件系统存放在磁盘上，多数磁盘被分为一个或多个分区，每个分区中有一个独立的文件系统</p>
</blockquote>
<p>磁盘的0号扇区称为<strong>主引导记录</strong>（MBR），用来引导计算机。在MBR的结尾是分区表，给出每个分区的起始和结束地址。表中的一个分区（不一定是第一个分区）被标记为活动分区</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240701005847547.png" alt="image-20240701005847547"></p>
<p>inode区记录文件的元信息</p>
<hr>
<h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><h4 id="连续空间存放方式"><a href="#连续空间存放方式" class="headerlink" title="连续空间存放方式"></a>连续空间存放方式</h4><hr>
<h4 id="非连续空间存放方式"><a href="#非连续空间存放方式" class="headerlink" title="非连续空间存放方式"></a>非连续空间存放方式</h4><h5 id="链表方式"><a href="#链表方式" class="headerlink" title="链表方式"></a>链表方式</h5><ul>
<li><p><strong>隐式链接</strong>：在每个数据块里面留出一个指针的空间，用来存放下一个数据块所在的地址</p>
</li>
<li><p><strong>显式链接（FAT）</strong>：Windows在<strong>内存</strong>中设计一个<strong>文件分配表</strong>（File Allocation Table，FAT）专门存放文件数据块的指针</p>
<p>文件分配表中的每个记录为下一个数据块所存放的物理磁盘块编号。虽然指针的使用跟链表差不多，但是其<strong>存在内存</strong>中，所以效率大大提高</p>
</li>
</ul>
<hr>
<h5 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h5><p><strong>索引结构inode</strong>（linux下）</p>
<p>inode通常包含：文件类型、文件大小（单位字节）、时间戳、链接数、文件权限、用户ID和组ID、数据块位置、其它系统相关属性</p>
<hr>
<h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><blockquote>
<p>将文件的地址映射直接加到链接目录下</p>
</blockquote>
<p>特性：</p>
<ul>
<li>文件有相同的inode及数据块</li>
<li>只能对已存在的文件进行创建</li>
<li>不能交叉文件系统进行硬链接的创建</li>
<li>不能对目录进行创建，只可对文件创建</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件（以文件副本的形式存在，但不占用实际空间）</li>
</ul>
<p>问题：文件的创建者没有权利断开已链接用户的链接</p>
<p>硬链接本质上是同一个文件的多个名字，它们共享相同的inode和数据块，只是文件名不同</p>
<p>建立硬链接时,引用计数值加1</p>
<hr>
<h4 id="软链接（符号链接）"><a href="#软链接（符号链接）" class="headerlink" title="软链接（符号链接）"></a>软链接（符号链接）</h4><blockquote>
<p>让系统建立一个类型为LINK的新文件，并把该文件放在其他共享文件使用者的目录下</p>
</blockquote>
<p>软链接则是一个特殊的文件，其中包含了指向另一个文件的路径名，可以理解为快捷方式或符号链接</p>
<p>建立软链接时,引用计数值是直接复制的</p>
<hr>
<h4 id="文件挂载"><a href="#文件挂载" class="headerlink" title="文件挂载"></a>文件挂载</h4><blockquote>
<p>挂载是一种将一个文件系统并入到另一个文件系统的方法</p>
</blockquote>
<p>比如光盘、U盘等都有自己的文件系统，插入到计算机后，将其文件系统并入到计算机的文件系统，从而可以对其进行访问</p>
<hr>
<h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><p>在给文件分配空间时，是以磁盘的盘块为基本单位分配的，必须记录磁盘可用于分配的盘块(即空闲盘块)，以及提供磁盘分配和回收的手段</p>
<p>实质上是对<strong>外存空闲区</strong>的组织和管理</p>
<h4 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h4><p><strong>位示图</strong>的位表示的是比特位(bit)，也就是一位二进制，在记录空闲空间的时候，主要需要完成的工作是将空闲的空间列出来，方便去调用，在某一个空闲空间被使用的时候，需要分配出去，如果用完之后，空间还可以被回收，在这里主要区别的就是这个块有没有被用，占用和空闲是两种不同的状态，来那种状态用一位二进制来表示就足够了。</p>
<p>在记录过程当中，可以用一位二进制的当中<strong>0表示这个磁盘块是空闲的</strong>，<strong>1表示磁盘块已经被占用</strong>，如果说对一个空闲磁盘块要分配出去，就把它当前位置上的0置为1就可以了，要回收的话就是把1改为0。</p>
<p><img src="/blog/2024/03/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20240701011606825.png" alt="image-20240701011606825"></p>
<blockquote>
<p>例题：某字长位32位的计算机的文件管理系统采用位示图（bitmap）记录磁盘的使用情况。若磁盘的容量为300GB，物理块的大小为1MB，那么位示图的大小为（<code>9600</code>）字。</p>
</blockquote>
<p>位示图表示的是磁盘情况，一个磁盘对应一个比特位来记录</p>
<p>磁盘总容量为300GB，也就是磁盘块大小为300GB</p>
<p>每一个物理块大小是1MB，则可以求出<code>磁盘块的数量=300GB/1MB</code>，**1GB和1MB之间转换是2<sup>10</sup>**，则<code>磁盘块的数量=300GB/1MB=300×2¹⁰</code><br>也就是需要300×2<sup>10</sup>个比特位来表示位示图</p>
<p>问一共需要多少个字？</p>
<p>题目中告知字长位32位的计算机，所以<code>需要的字=300×2¹⁰/32=300×2¹⁰/2⁵=300×32=9600</code></p>
<blockquote>
<p>文件系统用位图法表示磁盘空间的分配情况,位图存于磁盘的32~127号块中,每个盘块占1024个字节,盘块和块内字节从0开始编号。假设要释放的盘块号为409612,则位图中要修改的位所在的盘块号和块内字节序号分别是(82 、1 )</p>
</blockquote>
<p>盘块号b&#x3D;409612，字长n&#x3D;1024<br>盘块号对应的<code>字号(行)i=b/n(下取整)</code>，<code>位号(列)j=b%n</code><br>修改位所在的<code>字号i=409612/(1024*8)=50</code>，由于32块为起始块，所以修改位所在的<code>盘块号=32+50=82</code>，<code>位号=409612%1024=12</code>，则块内<code>字节序号=12%8=1</code></p>
<hr>
<h1 id="磁盘存储器管理"><a href="#磁盘存储器管理" class="headerlink" title="磁盘存储器管理"></a>磁盘存储器管理</h1>
    </div>
    
    
    
    
    
    
    
</div>

            </div>
        </transition>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/blog/js/main.js"></script>
    
    




    
    

<div id="vcomments"></div>

<script src="/blog/js/lib/valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: 'U9mZLKunkRUTcBFthjXPjnZE-9Nh9j0Va',
        app_key: 'SzWOnY0PWLGNuL6jW8TZYc7j',
        visitor: 'true',
        placeholder: '写点什么吧(●ˇ∀ˇ●)',
        serverURLs: 'https://u9mzlkun.lc-cn-n1-shared.com',
    });
</script>

    <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 雲流のLowest World
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;C1oudfL0w0
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

<script src="/blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/blog/live2dw/assets/z16.model.json"},"display":{"position":"left","width":150,"height":290},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>